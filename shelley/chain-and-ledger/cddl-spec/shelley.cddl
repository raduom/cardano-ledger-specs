; Shelley Types

; When you have something that is always length 2, why do you need the header?
; Would using a map here make it cheaper?
block =
  [ header                     : header
  , transaction_bodies         : [* transaction_body]
  , transaction_witness_sets   : [* transaction_witness_set]
  ]

header =
  [ header_body
  , body_signature : $kes_signature
  ]

header_body =
  ( prev_hash        : $hash
  , issuer_vkey      : $vkey
  , vrf_vkey         : $vrf_vkey
  , slot             : uint
  , nonce            : uint
  , nonce_proof      : $vrf_proof
  , leader_value     : unit_interval
  , leader_proof     : $vrf_proof
  , size             : uint
  , block_body_hash  : $hash            ; merkle pair root
  , operational_cert
  , protocol_version
  )

operational_cert =
  ( hot_vkey        : $kes_vkey
  , cold_vkey       : $vkey
  , sequence_number : uint
  , kes_period      : uint
  , sigma           : $signature
  )

protocol_version = (uint, uint, uint)

; Do we want to use a Map here? Is it actually cheaper?
; Do we want to add extension points here?
transaction_body =
  { 0 : #6.258([* transaction_input])
  , 1 : [* transaction_output]
  , 2 : [* delegation_certificate]
  , 3 : [* withdrawal]
  , 4 : coin ; fee
  , 5 : uint ; ttl
  , 6 : update
  }

; Is it okay to have this as a group? Is it valid CBOR?! Does it need to be?
transaction_input = [transaction_id : $hash, index : uint]

transaction_output = [address, amount : uint]

address =
 (  0, keyhash, keyhash       ; base address
 // 1, keyhash, scripthash    ; base address
 // 2, scripthash, keyhash    ; base address
 // 3, scripthash, scripthash ; base address
 // 4, keyhash, pointer       ; pointer address
 // 5, scripthash, pointer    ; pointer address
 // 6, keyhash                ; enterprise address (null staking reference)
 // 7, scripthash             ; enterprise address (null staking reference)
 // 8, keyhash                ; bootstrap address
 )


delegation_certificate =
  [( 0, keyhash         ; stake key registration
  // 1, scripthash      ; stake script registration
  // 2, keyhash         ; stake key de-registration
  // 3, scripthash      ; stake script de-registration
  // 4                  ; stake key delegation
      , keyhash         ; delegating key
      , keyhash         ; key delegated to
  // 5                  ; stake script delegation
      , scripthash      ; delegating script
      , keyhash         ; key delegated to
  // 6, keyhash, pool_params  ; stake pool registration
  // 7, keyhash, epoch  ; stake pool retirement
  // 8                  ; genesis key delegation
      , genesishash     ; delegating key
      , keyhash         ; key delegated to
  // 9, [* move_instantaneous_reward] ; move instantaneous rewards
 ) ]

move_instantaneous_reward = ( keyhash, coin )
pointer = (uint, uint, uint)

credential =
  (  0, keyhash
  // 1, scripthash
  // 2, genesishash
  )

coin = uint

epoch = uint

keyhash = $hash
scripthash = $hash

pool_params = ( #6.258([* keyhash])
              , coin               ; cost
              , unit_interval      ; margin
              , coin               ; pledge
              , keyhash            ; operator
              , $vrf_keyhash       ; vrf keyhash
              , [credential]       ; reward_account
              )

withdrawal = [credential, amount : uint]

update = undefined

transaction_witness_set =
  (  0, vkeywitness
  // 1, $script
  // 2, [* vkeywitness]
  // 3, [* $script]
  // 4, [* vkeywitness],[* $script]
  )

vkeywitness = [$vkey, $signature]

; Crypto Types will be defined for mock and real crypto in separate files using this syntax

genesishash = $hash

$hash /= bytes

$vkey /= bytes

$signature /= bytes

$vrf_keyhash /= bytes

$vrf_vkey /= bytes
$vrf_proof /= bytes

$kes_vkey /= bytes

$kes_signature /= bytes

; Numeric Types

unit_interval =
  [ numerator   : uint
  , denominator : uint
  ]
