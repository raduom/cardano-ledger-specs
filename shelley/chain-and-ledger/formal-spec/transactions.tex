\section{Transactions}
\label{sec:transactions}

In Figure \ref{fig:defs:utxo-shelley-1}, we give the transaction types modified
to support Plutus scripts. These types are consistent with the Shelley ledger
as much as possible,
except for the following changes:

\begin{itemize}
  \item $\CurrencyId,~\Token,~\Quantity$ are all types
  related to native multicurrency on the ledger.

  \item $\Yes$ and $\Nope$: These are single-value types used in tags. These
  values are used instead of booleans for clarity.

  \item $\ScriptPlutus$ and $\ScriptMSig$ are two types of scripts this spec
  covers validation of

  \item $\IsFee$ is a tag that indicates when an input has been marked
  to be used for paying transaction fees ($\Yes$ for when it is for fees,
  $\Nope$ when it is not).

  \item $\IsValidating$ is a tag that indicates when a transaction is
  expected to have all the scripts inside it validate.
  This value is added by the slot leader when
  constructing a block, and checked when a node runs all the scripts.
  $\Yes$ for when it is for when all scripts will validate,
  $\Nope$ is for when one of them does not.

  \item $\Data$: is the type of all arguments passed to the validator script.

  \item $\ScriptV,~ \Rdmr,~ \DatVal$: are the types of the validator,
  redeemer and data.

  \item $\Value$ is the multicurrency type used to represent
  both fungible and non fungible tokens

  \item $\TxInScr$: A transaction input spending a script output. It must
  include the hash of the redeemer.

  \item $\TxInTx$: A transaction input (now distinct from the input $\TxIn$ in
  a UTxO entry). Can be a PK-address spending input
  (in which case $\IsFee$ indicates if this input should be used to pay script execution
  fees), or a script-spending input.

  \item $\TxOut,~\TxOutVK,~\TxOutScr$: An arbitrary output type (script or PK),
  as well as special output types for PK and script outputs. The script output
  includes a data script hash.

  \item $\UTxO$ now includes the slot number the output was created in the
  output

  \item $\Vlds$ are types which are finite maps for looking up
  validator scripts by hashes.
\end{itemize}


\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{curid} & \CurrencyId & \text{currency id}\\
      \var{tok} & \Token & \text{token identifier}\\
      \var{quan} & \Quantity & \text{quantity of a token}\\
      \var{plc} & \ScriptPlutus & \text{Plutus scripts} \\
      \var{msig} & \ScriptMSig & \text{Multisig scripts} \\
      \var{yes} & \Yes & \text{tag type for yes} \\
      \var{no} & \Nope & \text{tag type for no} \\
    \end{array}
  \end{equation*}
  \emph{Script types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{scr} & \Script & \ScriptPlutus \uniondistinct \ScriptMSig \\
      \var{isv} & \IsValidating & \Yes \uniondistinct \Nope \\
      \var{dat}
      & \Data
      & \Nothing \uniondistinct \mathbb{N}\uniondistinct\mathbb{H}\uniondistinct(\mathbb{N}\times\seqof{\Data})
        \uniondistinct\seqof{\Data}\uniondistinct\seqof{\Data \times \Data}
      & \text{the $\Data$ type}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\subset}lr}
      \var{script_v}&\ScriptV & \Script & \text{validator script}\\
      \var{dataval}&\DatVal & \Data & \text{data script}\\
      \var{rdmr}&\Rdmr & \Data & \text{redeemer script}\\
    \end{array}
  \end{equation*}
%
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{val} & \Value
      & \CurrencyId \mapsto (\Token \mapsto \Quantity)
%      & \text{a collection of tokens}
      \\
      \var{isf}
      & \IsFee
      & \Yes \uniondistinct \Nope
%      & \text {tag for inputs used to pay script fees}
      \\
      (\var{txid}, \var{ix})
      & \type{TxIn}
      & \TxId \times \Ix
%      & \text{UTxO entry reference}
      \\
      (\var{txid}, \var{ix}, \var{hash_r})
      & \type{TxInScr}
      & \TxIn \times \HashDat
%      & \text{script input}
      \\
      \var{txin}
      & \TxInTx
      & (\TxIn \times \IsFee) \uniondistinct \TxInScr
%      & \text{transaction input}
      \\
      (\var{addr}, v)
      & \type{TxOutVK}
      & \Addr \times \Value
%      & \text{vk address output}
      \\
      (\var{addr}, v, \var{hashscr_d})
      & \type{TxOutScr}
      & \type{TxOutVK} \times \HashDat
%      & \text{script address output}
      \\
      \var{txout}
      & \TxOut
      & \TxOutVK \uniondistinct \TxOutScr
%      & \text{transaction outputs}
      \\
      \var{utxo}
      & \UTxO
      & \TxIn \mapsto (\TxOut \times \Slot)
%      & \text{unspent tx outputs}
      \\
      \var{wdrl}
      & \Wdrl
      & \AddrRWD \mapsto \Value
%      & \text{reward withdrawal}
      \\
      \var{val}
      & \Vlds
      & \HashScr \mapsto \Script
%      & \text{hash and validator}
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system}
  \label{fig:defs:utxo-shelley-1}
\end{figure*}

The types for passing to Plutus scripts are added in Figure \ref{fig:defs:utxo-pending}.
There is current item $\CurItem$, which represents either the current input being
spent, the current certificated being validated, or the current reward
withdrawal. $\ScrInData$ is all the input data for a script. It is
just validation data for MSIG, and data value, redeemer and validation data for PLC.


\begin{figure*}[htb]
  \emph{Validation Data Types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{cur}
      & \CurItem
      & \Nothing \uniondistinct \TxInTx \uniondistinct \Wdrl \uniondistinct \DCert
      \\
      \var{sid}
      & \ScrInData
      & \Data \uniondistinct
        (\Data \times \Data \times \Data)
    \end{array}
  \end{equation*}
  \caption{Definitions used to make Validation Data}
  \label{fig:defs:utxo-pending}
\end{figure*}


In Figure \ref{fig:defs:utxo-shelley-2}, the following types have changed:

\begin{itemize}
  \item $\TxBody$ was changed to have inputs of type $\TxInTx$, and the
  time to live $\Slot$ was replaced by a liveness interval $\Slot \times \Slot$,
  where the first slot is accessed by $\fun{txlst}$.
  \item The fee, now represented by type $\Value$, includes both script and
  non-script transaction fee portions
  \item $\TxBody$ now includes $\Value$, which represents
  the tokens forged and taken out of circulation by the transaction
  \item $\TxBody$ now includes $\ExUnits$, which are the total execution units
  that will be used by all scripts
  \item $\TxBody$ also has the hash of the current protocol parameters
  (only the ones relevant to Plutus script validation), $\HashPP^?$,
  which is only obligatory to include when a transaction is carrying scripts
  \item Not as part of the body, the transaction now also includes
  a finite map lookup $\Vlds$ to avoid having multiple
  copies of the validator (one for each input spending from that script).
  \item $\HashDat \mapsto \Data$ is a similar lookup for $\Data$.
  The full data script is now optional to include in a transaction when
  paying to a script. It is never
  stored on-chain and is only provided for the spender of the output
  to be able to look it up when necessary (i.e. when spending the output),
  provided the block that contained it is still available to the spender.
  Supplying the full data script increases the size of the transaction and
  thus the fees.
  \item $\IsValidating$ is now part of the $\Tx$ type. This is a tag that is
  set by the slot leader submitting the block containing this transaction.
  It can later be used to re-apply blocks without performing script validation
  again.
  \item $\TxWitness$ is changed to exclude script witnesses. Only PK ones
  are included. Scripts are handled separately.
  \item $\fun{txinputs}$ type changed to map to $\TxInTx$
  \item Accessor functions added
\end{itemize}



\begin{figure*}[htb]
  \emph{Transaction Types}
  %
  \begin{align*}
    \var{txbody} ~\in~
    & \TxBody ~=~
    & \powerset{\TxInTx} \times (\Ix \mapsto \TxOut) \times \seqof{\DCert}
      \times \Value \times \ExUnits \times \Value \\
    & ~& \times (\Slot\times\Slot) \times~ \Wdrl \times \Update \times \HashPP^?
  \end{align*}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{wit} & \TxWitness & (\VKey \mapsto \Sig)
      \\
      \var{tx}
      & \Tx
      & \TxBody \times \TxWitness \times \Vlds \times (\HashDat \mapsto \Data)
      \times \IsValidating
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txfee} & \Tx \to \Slot & \text{fee as Value} \\
      \fun{txinputs} & \Tx \to \powerset{\TxInTx} & \text{transaction inputs} \\
      \fun{txlst} & \Tx \to \Slot & \text{start of liveness interval} \\
      \fun{getValue} & \TxOut \to \Value & \text{output value} \\
      \fun{getAddr} & \TxOut \to \Addr & \text{output address} \\
      \fun{inref} & \TxInTx \to \TxIn & \text{input reference $(txid,ix)$} \\
      \fun{getDataHash} & \TxOut \to \HashDat & \text{data script hash} \\
      \fun{forged} & \Tx \to \Value & \text{value forged by tx}\\
      \fun{txexunits} & \Tx \to \ExUnits & \text{portion of fee allocated for scripts}\\
      \fun{hashPP} & \Tx \to \HashPP^? & \text{hash of the protocol params}\\
      \fun{txvaltag} & \Tx \to \IsValidating & \text{transaction validation tag}\\
      \fun{txvlds} & \Tx \to \Vlds & \text{validator scripts}\\
      \fun{txdats} & \Tx \to (\HashDat \mapsto \Data) & \text{data scripts}\\
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system, cont.}
  \label{fig:defs:utxo-shelley-2}
\end{figure*}


In Figure \ref{fig:defs:functions-helper} are the helper functions used for
processing transaction data for validation.

\begin{itemize}
  \item $\fun{adaID},~\fun{adaToken}$ are
  added for use of native currency Ada in multicurrency.
  \item $\fun{hashScript},~ \fun{hashData}$ are abstract hashing functions.
  ($\fun{validationData}$ builds it).
\end{itemize}

\begin{figure*}[htb]
  \emph{Abstract Functions and Values}
  %
  \begin{align*}
    \mathsf{adaID} \in& ~\CurrencyId
    & \text{Ada currency ID} \\
    \mathsf{adaToken} \in& ~\Token
    & \text{Ada Token} \\
    \fun{hashScript} \in & ~\Script\to \HashScr
    & \text{compute script hash} \\
    \fun{hashData} \in & ~\Data \to \HashDat
    & \text{compute hash of data} \\
    \fun{validationData} \in & \UTxO \to \Tx \to \CurItem \to \Data
    & \text{build Validation Data} \\
  \end{align*}
  \caption{Script Validation}
  \label{fig:defs:functions-helper}
\end{figure*}


In Figure \ref{fig:defs:functions-valid}, functions for script validation
are presented.

\begin{itemize}
  \item $\fun{valMSIGupTo}$ performs validation for multi-sig scripts
  (this does not require data or redeemer scripts).
  \item $\fun{valPLCupTo}$ performs validation for Plutus scripts.
\end{itemize}

These functions take their corresponding parameters (no data or redeemer
scripts in the case of multisig). They also
takes a term of type $\ExUnits$ as a parameter and perform validation
\textit{limited by resources indicated by} this value.
In order to perform the calculation which converts primitive resource use into an
abstract units, the $\CostMod$ is also passed as parameters.
The evaluation functions return a pair
of the boolean validation result and the remaining $\ExUnits$ available
for validation of the rest of the scripts in the transaction (if any).

\begin{note}
  $\fun{valScriptUpTo}$  is the name of the function that replaces
  $\fun{evaluateScript}$ in the existing multi-sig script validation
  scheme in the ledger spec.
\end{note}

\begin{figure*}[htb]
  \emph{Script Validation Functions}
  %
  \begin{align*}
    & \fun{valMSIGupTo} \in \CostMod \to\ScriptMSig\to \Data \to
    \ExUnits \to (\IsValidating \times \ExUnits) \\
    & \text{resource-restricted validation of a multi-sig script} \\~\\
    & \fun{valPLCupTo} \in \CostMod \to\ScriptPlutus\to
    (\Data \times \Data \times \Data \times
    \ExUnits) \to (\IsValidating \times \ExUnits) \\
    & \text{resource-restricted validation of a Plutus script}
  \end{align*}
  %
  \emph{Notation}
  %
  \begin{align*}
    \llbracket \var{script_v} \rrbracket_{\var{cm},\var{exunits}}(\var{dataval},~\var{rdmr},~\var{ptx})
    &=& \fun{valPLCupTo} ~{cm}~\var{script_v}~(\var{dataval},~\var{rdmr},~\var{ptx},~
    \var{exunits})
    \nextdef
    \llbracket \var{script_v} \rrbracket_{\var{cm},\var{exunits}} \var{ptx}
    &=& \begin{cases}
    \fun{valPLCupTo} ~\var{cm}~\var{script_v} ~ \var{\Nothing}~\var{\Nothing}~\var{ptx}~
    \var{exunits} ~& \text{if}~\var{script_v} \in \ScriptPlutus \\
    \fun{valMSIGupTo} ~\var{cm}~\var{script_v} ~\var{ptx}~
    \var{exunits} & \text{if}~\var{script_v} \in \ScriptMSig
      \end{cases}\\
  \end{align*}
  \caption{Script Validation, cont.}
  \label{fig:defs:functions-valid}
\end{figure*}


\clearpage
