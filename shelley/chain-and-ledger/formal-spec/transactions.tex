\section{Transactions}
\label{sec:transactions}

In Figure \ref{fig:defs:utxo-shelley-1}, we give the transaction types modified
to support Plutus scripts. These types are consistent with the Shelley ledger
as much as possible,
except for the following changes:

\begin{itemize}
  \item $\Coin,~\CurrencyId,~\Token,~\Quantity$ are all types
  related to native multicurrency on the ledger.

  \item $\Yes$ and $\Nope$: These are single-value types used in tags. These
  values are used instead of booleans for clarity.

  \item $\ScriptPlutus$ and $\ScriptMSig$ are two types of scripts this spec
  covers validation of

  \item $\IsFee$ is a tag that indicates when an input has been marked
  to be used for paying transaction fees ($\Yes$ for when it is for fees,
  $\Nope$ when it is not).

  \item $\IsValidating$ is a tag that indicates when a transaction is
  expected to have all the scripts inside it validate.
  This value is added by the slot leader when
  constructing a block, and checked when a node runs all the scripts.
  $\Yes$ for when it is for when all scripts will validate,
  $\Nope$ is for when one of them does not.

  \item $\Data$: is the type of all arguments passed to the validator script.

  \item $\ScriptV,~ \ScriptR,~ \ScriptD$: are the types of the validator,
  redeemer and data scripts.

  \item $\Value$ is the multicurrency type used to represent
  both fungible and non fungible tokens

  \item $\Info$: is the additional information an input in a transaction must
  have when spending a script output. This includes the redeemer,
  data.

  \item $\TxInScr$: A transaction input spending a script output.

  \item $\TxInTx$: A transaction input (now distinct from the input $\TxIn$ in
  a UTxO entry). Can be a PK-address spending input
  (in which case $\IsFee$ indicates if this input should be used to pay script execution
  fees), or a script-spending input.

  \item $\TxOut,~\TxOutVK,~\TxOutScr$: An arbitrary output type (script or PK),
  as well as special output types for PK and script outputs. The script output
  includes a data script hash.

  \item $\Vlds$ are types which are finite maps for looking up
  validator scripts by hashes.
\end{itemize}


\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{c} & \Coin & \text{Ada value}\\
      \var{curid} & \CurrencyId & \text{currency id}\\
      \var{tok} & \Token & \text{token identifier}\\
      \var{quan} & \Quantity & \text{quantity of a token}\\
      \var{plc} & \ScriptPlutus & \text{Plutus scripts} \\
      \var{msig} & \ScriptMSig & \text{Multisig scripts} \\
      \var{yes} & \Yes & \text{tag type for yes} \\
      \var{no} & \Nope & \text{tag type for no} \\
    \end{array}
  \end{equation*}
  \emph{Script types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{scr} & \Script & \ScriptPlutus \uniondistinct \ScriptMSig \\
      \var{isv} & \IsValidating & \Yes \uniondistinct \Nope \\
      \var{dat}
      & \Data
      & \Nothing \uniondistinct \mathbb{N}\uniondistinct\mathbb{H}\uniondistinct(\mathbb{N}\times\seqof{\Data})
        \uniondistinct\seqof{\Data}\uniondistinct\seqof{\Data \times \Data}
      & \text{the $\Data$ type}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\subset}lr}
      \var{script_v}&\ScriptV & \Script & \text{validator script}\\
      \var{script_d}&\ScriptD & \Data & \text{data script}\\
      \var{script_r}&\ScriptR & \Data & \text{redeemer script}\\
    \end{array}
  \end{equation*}
%
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{val} & \Value
      & \CurrencyId \mapsto (\Token \mapsto \Quantity)
%      & \text{a collection of tokens}
      \\
      \var{isf}
      & \IsFee
      & \Yes \uniondistinct \Nope
%      & \text {tag for inputs used to pay script fees}
      \\
      (\var{txid}, \var{ix})
      & \type{TxIn}
      & \TxId \times \Ix
%      & \text{UTxO entry reference}
      \\
      \var{(\var{script_d},\var{script_r})}
      & \Info
      & \ScriptD \times \ScriptR
%      & \text{validation data}
      \\
      (\var{txid}, \var{ix}, \var{inf})
      & \type{TxInScr}
      & \TxIn \times \Info
%      & \text{script input}
      \\
      \var{txin}
      & \TxInTx
      & (\TxIn \times \IsFee) \uniondistinct \TxInScr
%      & \text{transaction input}
      \\
      (\var{addr}, v)
      & \type{TxOutVK}
      & \Addr \times \Value
%      & \text{vk address output}
      \\
      (\var{addr}, v, \var{hashscr_d})
      & \type{TxOutScr}
      & \type{TxOutVK} \times \HashDat
%      & \text{script address output}
      \\
      \var{txout}
      & \TxOut
      & \TxOutVK \uniondistinct \TxOutScr
%      & \text{transaction outputs}
      \\
      \var{utxo}
      & \UTxO
      & \TxIn \mapsto \TxOut
%      & \text{unspent tx outputs}
      \\
      \var{wdrl}
      & \Wdrl
      & \AddrRWD \mapsto \Coin
%      & \text{reward withdrawal}
      \\
      \var{val}
      & \Vlds
      & \HashScr \mapsto \Script
%      & \text{hash and validator}
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system}
  \label{fig:defs:utxo-shelley-1}
\end{figure*}

The types for $\ValidationData$ are added in Figure \ref{fig:defs:utxo-pending}.
There is current item $\CurItem$, which represents either the current input being
spent, the current certificated being validated, or the current reward
withdrawal. $\ScrInData$ is all the input data for a script (either MSIG or PLC).

\begin{figure*}[htb]
  \emph{Abstract Types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{vd}
      & \ValidationData
      & \text{Data which must be passed to a Plutus script}
    \end{array}
  \end{equation*}
  \emph{ValidationData Types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{cur}
      & \CurItem
      & \TxInTx \uniondistinct \Wdrl \uniondistinct \DCert
      \\
      \var{sid}
      & \ScrInData
      & (\CostMod \times \Data) \uniondistinct (\CostMod \times \Data \times \Data \times \Data)
    \end{array}
  \end{equation*}
  \caption{Definitions used to make ValidationData}
  \label{fig:defs:utxo-pending}
\end{figure*}


In Figure \ref{fig:defs:utxo-shelley-2}, the following types have changed:

\begin{itemize}
  \item $\TxBody$ was changed to have inputs of type $\TxInTx$, and the
  time to live $\Slot$ was replaced by a liveness interval $\Slot \times \Slot$,
  where the first slot is accessed by $\fun{txlst}$.
  \item $\TxBody$ now includes $\Value$, which represents
  the tokens forged and taken out of circulation by the transaction
  \item Not as part of the body, the transaction now also includes
  a finite map lookup $\Vlds$ to avoid having multiple
  copies of the validator (one for each input spending from that script).
  \item $\HashDat \mapsto \Data$ is a similar lookup for data scripts.
  The full data script is now optional to include in a transaction when
  paying to a script. It is never
  stored on-chain and is only provided for the spender of the output
  to be able to look it up when necessary (i.e. when spending the output),
  provided the block that contained it is still available to the spender.
  Supplying the full data script increases the size of the transaction and
  thus the fees.
  \item $\IsValidating$ is now part of the $\Tx$ type. This is a tag that is
  set by the slot leader submitting the block containing this transaction.
  It can later be used to re-apply blocks without performing script validation
  again.
  \item $\TxWitness$ is changed to exclude script witnesses. Only PK ones
  are included. Scripts are handled separately.
  \item $\fun{txinputs}$ type changed to map to $\TxInTx$
  \item $~\fun{txlst},~\fun{getValue},~\fun{getAddr}, ~\fun{getDataHash},
  ~\fun{txlst},~\fun{txvlds},~\fun{txdats},
  ~\fun{forged}$
  accessor functions added
\end{itemize}



\begin{figure*}[htb]
  \emph{Transaction Types}
  %
  \begin{align*}
    \var{txbody} ~\in~
    & \TxBody ~=~
    & \powerset{\TxInTx} \times (\Ix \mapsto \TxOut) \times \seqof{\DCert}
      \times \Coin \times \Value \times (\Slot\times\Slot) \\
    & ~& \times~ \Wdrl \times \Update
  \end{align*}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{wit} & \TxWitness & (\VKey \mapsto \Sig)
      \\
      \var{tx}
      & \Tx
      & \TxBody \times \TxWitness \times \Vlds \times (\HashDat \mapsto \Data) \times \IsValidating
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txinputs} & \Tx \to \powerset{\TxInTx} & \text{transaction inputs} \\
      \fun{txlst} & \Tx \to \Slot & \text{start of liveness interval} \\
      \fun{getValue} & \TxOut \to \Value & \text{output value} \\
      \fun{getAddr} & \TxOut \to \Addr & \text{output address} \\
      \fun{getDataHash} & \TxOut \to \HashDat & \text{data script hash} \\
      \fun{txvaltag} & \Tx \to \IsValidating & \text{transaction validation tag}\\
      \fun{txvlds} & \Tx \to \Vlds & \text{validator scripts}\\
      \fun{txdats} & \Tx \to (\HashDat \mapsto \Data) & \text{data scripts}\\
      \fun{forged} & \Tx \to \Value & \text{value forged by tx}\\
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system, cont.}
  \label{fig:defs:utxo-shelley-2}
\end{figure*}


In Figure \ref{fig:defs:functions-helper} are the helper functions used for
processing transaction data for validation.

\begin{itemize}
  \item $\fun{adaID},~\fun{adaToken},~\fun{qu},~\fun{coi},~\fun{adaVal}$ are used
  for converting between Ada and other currencies. $\Quantity$ and $\Coin$
  must both be of the same underlying type to be able to convert between them.
  \item $\fun{hashScript},~ \fun{hashData},~\fun{toData}$ are hashing and encoding
  abstract functions.
  \item $\fun{adaVal}$ is used to create a value term from a coin Ada amount
  \item The other functions are needed for building $\ValidationData$
  ($\fun{validationData}$ builds it).
\end{itemize}

\begin{figure*}[htb]
  \emph{Abstract Functions and Values}
  %
  \begin{align*}
    \mathsf{adaID} \in& ~\CurrencyId
    & \text{Ada currency ID} \\
    \mathsf{adaToken} \in& ~\Token
    & \text{Ada Token} \\
    \fun{qu} \in& ~\Coin \to \Quantity
    & \text{convert a coin amount into quantity} \\
    \fun{coi} \in& ~\Quantity \to \Coin
    & \text{convert a quantity into a coin value} \\
    \fun{hashScript} \in & ~\Script\to \HashScr
    & \text{compute script hash} \\
    \fun{hashData} \in & ~\Data \to \HashDat
    & \text{compute hash of data} \\
    \fun{toData} \in & ~ \ValidationData\to \Data
    & \text{encode ValidationData as Data} \\
    \fun{validationData} \in & \UTxO \to \Tx \to \CurItem \to \ValidationData
    & \text{build ValidationData} \\
  \end{align*}
  \emph{Helper Functions}
  %
  \begin{align*}
    &\fun{adaVal} ~\in~ \Coin \to \Value \\
    &\fun{adaVal}~{c} ~=~ \mathsf{adaID} \mapsto (\mathsf{adaToken} \mapsto  \fun{qu}~c) \\
    & \text{make an Ada value term from a Coin} \\~\\
  \end{align*}
  \caption{Script Validation}
  \label{fig:defs:functions-helper}
\end{figure*}


In Figure \ref{fig:defs:functions-valid}, functions for script validation
are presented.

\begin{itemize}
  \item $\fun{valMSIGupTo}$ performs validation for multi-sig scripts
  (this does not require data or redeemer scripts).
  \item $\fun{valPLCupTo}$ performs validation for plutus scripts.
  \begin{note}
    these need to be defined still
  \end{note}
\end{itemize}

These functions take their corresponding parameters (no data or redeemer
scripts in the case of multisig). They also
takes a term of type $\Coin$ as a parameter and perform validation
\textit{limited by resources indicated by} this value. They return a pair
of the boolean validation result and the remaining funds available to pay
for validation of the rest of the scripts in the transaction (if any).

\begin{note}
  $\fun{valScriptUpTo}$  is the name of the function that replaces
  $\fun{evaluateScript}$ in the existing multi-sig script validation
  scheme in the ledger spec.
\end{note}

\begin{figure*}[htb]
  \emph{Script Validation Functions}
  %
  \begin{align*}
    & \fun{valMSIGupTo} \in \CostMod \to\ScriptMSig\to \Data \to \Coin \to \Bool \times \Coin \\
    & \text{resource-restricted validation of a multi-sig script} \\~\\
    & \fun{valPLCupTo} \in \CostMod \to\ScriptPlutus\to (\Data \times \Data \times \Data \times
    \Coin) \to \Bool \times \Coin \\
    & \text{resource-restricted validation of a Plutus script}
  \end{align*}
  %
  \emph{Notation}
  %
  \begin{align*}
    \llbracket \var{script_v} \rrbracket_{\var{c},\var{cm}} (\var{script_d},~\var{script_r},~\var{ptx})
    &=& \fun{valPLCupTo} ~{cm}~\var{script_v}~(\var{script_d},~\var{script_r},~\var{ptx},~
    \var{c})
    \nextdef
    \llbracket \var{script_v} \rrbracket_{\var{c},\var{cm}} ~\var{ptx}
    &=& \begin{cases}
    \fun{valPLCupTo} ~\var{cm}~\var{script_v} ~ \var{\Nothing}~\var{\Nothing}~\var{ptx}~
    \var{c} ~& \text{if}~\var{script_v} \in \ScriptPlutus \\
    \fun{valMSIGupTo} ~\var{cm}~\var{script_v} ~\var{ptx}~
    \var{c} & \text{if}~\var{script_v} \in \ScriptMSig
      \end{cases}\\
  \end{align*}
  \caption{Script Validation, cont.}
  \label{fig:defs:functions-valid}
\end{figure*}


\clearpage
