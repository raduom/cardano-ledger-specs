\section{Transactions}
\label{sec:transactions}

In Figure \ref{fig:defs:utxo-shelley-1}, we give the transaction types modified
to support Plutus scripts. These types are consistent with the Shelley ledger
as much as possible,
except for the following changes:

\begin{itemize}
  \item $\Coin,~\CurrencyId,~\Token,~\Quantity$ are all types
  related to native multicurrency on the ledger.

  \item $\ForFee$ and $\NForFee$: These are tags used to sort public key
  spending inputs in a transaction into those used to pay script validation
  fees and those not used
  for fees. $\IsFee$ represents either.

  \item $\ScriptPlutus$ and $\ScriptMSig$ are two types of scripts this spec
  covers validation of

  \item $\ValTag$ and $\InValTag$: These are tags used to indicate if all scripts
  in a transaction are expected to validate.
  $\TxValTag$ represents either.

  \item $\Data$: is the type of all arguments passed to the validator script.

  \item $\ScriptV,~ \ScriptR,~ \ScriptD$: are the types of the validator,
  redeemer and data scripts.

  \item $\Value$ is the multicurrency type used to represent
  both fungible and non fungible tokens

  \item $\Info$: is the additional information an input in a transaction must
  have when spending a script output. This includes the redeemer,
  data, and
  the resource consumption for validating spending the script output
  , expressed as $\var{exunits}$.

  \item $\TxInScr$: A transaction input spending a script output.

  \item $\TxInTx$: A transaction input (now distinct from the input $\TxIn$ in
  a UTxO entry). Can be a PK-address spending input
  (in which case $\IsFee$ indicates if this input should be used to pay script execution
  fees), or a script-spending input.

  \item $\TxOut,~\TxOutVK,~\TxOutScr$: An arbitrary output type (script or PK),
  as well as special output types for PK and script outputs. The script output
  includes a data script hash.

  \item $\VldSR,~\VldOut,~\Vlds$ are types which are finite maps for looking up
  validator scripts by hashes. The scripts witnessing reward withdrawals and
  scripts
  do not have an input containing the execution cost, so the execution cost
  is paired with the hash in the $\VldSR$ type for such scripts.
\end{itemize}


\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{c} & \Coin & \text{Ada value}\\
      \var{curid} & \CurrencyId & \text{currency id}\\
      \var{tok} & \Token & \text{token identifier}\\
      \var{quan} & \Quantity & \text{quantity of a token}\\
      \var{f} & \ForFee & \text{inputs intended for script fees} \\
      \var{nf} & \NForFee & \text{inputs not for script fees} \\
      \var{plc} & \ScriptPlutus & \text{Plutus scripts} \\
      \var{msig} & \ScriptMSig & \text{Multisig scripts} \\
      \var{vt} & \InValTag & \text{transaction valid tag} \\
      \var{ivt} & \ValTag & \text{transaction invalid tag} \\
    \end{array}
  \end{equation*}
  \emph{Script types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{scr} & \Script & \ScriptPlutus \uniondistinct \ScriptMSig \\
      \var{tvtag} & \TxValTag & \ValTag \uniondistinct \InValTag \\
      \var{dat}
      & \Data
      & \Nothing \uniondistinct \mathbb{N}\uniondistinct\mathbb{H}\uniondistinct(\mathbb{N}\times\seqof{\Data})
        \uniondistinct\seqof{\Data}\uniondistinct\seqof{\Data \times \Data}
      & \text{the $\Data$ type}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\subset}lr}
      \var{script_v}&\ScriptV & \Script & \text{validator script}\\
      \var{script_d}&\ScriptD & \Data & \text{data script}\\
      \var{script_r}&\ScriptR & \Data & \text{redeemer script}\\
    \end{array}
  \end{equation*}
%
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{val} & \Value
      & \CurrencyId \mapsto (\Token \mapsto \Quantity)
      & \text{a collection of tokens}
      \\
      \var{isf}
      & \IsFee
      & \ForFee \uniondistinct \NForFee
      & \text {tag for inputs used to pay script fees}
      \\
      (\var{txid}, \var{ix})
      & \type{TxIn}
      & \TxId \times \Ix
      & \text{UTxO entry reference}
      \\
      \var{(\var{script_d},\var{script_r},\var{exunits})}
      & \Info
      & \ScriptD \times \ScriptR \times \ExUnits
      & \text{validation data}
      \\
      (\var{txid}, \var{ix}, \var{inf})
      & \type{TxInScr}
      & \TxIn \times \Info
      & \text{script input}
      \\
      \var{txin}
      & \TxInTx
      & (\TxIn \times \IsFee) \uniondistinct \TxInScr
      & \text{transaction input}
      \\
      (\var{addr}, v)
      & \type{TxOutVK}
      & \Addr \times \Value
      & \text{vk address output}
      \\
      (\var{addr}, v, \var{hashscr_d})
      & \type{TxOutScr}
      & \type{TxOutVK} \times \HashDat
      & \text{script address output}
      \\
      \var{txout}
      & \TxOut
      & \TxOutVK \uniondistinct \TxOutScr
      & \text{transaction outputs}
      \\
      \var{utxo}
      & \UTxO
      & \TxIn \mapsto \TxOut
      & \text{unspent tx outputs}
      \\
      \var{wdrl}
      & \Wdrl
      & \AddrRWD \mapsto \Coin
      & \text{reward withdrawal}
      \\
      \var{h \mapsto (hashscr_v,exunits)}
      & \VldSR
      & \HashScr \mapsto (\Script \times \ExUnits)
      & \text{hash and validator with no data or redeemer}
      \\
      \var{h \mapsto hashscr_v}
      & \VldOut
      & \HashScr \mapsto \Script
      & \text{hash and validator for output}
      \\
      \var{val}
      & \Vlds
      & \VldOut \uniondistinct \VldSR
      & \text{hash and validator}
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system}
  \label{fig:defs:utxo-shelley-1}
\end{figure*}

The types for PendingTx are added in Figure \ref{fig:defs:utxo-pending}.
These roughly match the types currently in the master plutus branch,
with the exception that the "current input" is now represented by the type
$\PendingTxInSRC$, which can accommodate not only the currently script input
being validated, but also the cases when a certificate or a reward withdrawal
is being validated.

\begin{figure*}[htb]
  \emph{PendingTx Types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{ptxiv}
      & \PendingTxInV
      & \TxIn \times \Value
      \\
      \var{ptxis}
      & \PendingTxInS
      & \TxIn \times (\HashScr \times \HashDat) \times \Value
      \\
      \var{ptxrs}
      & \PendingTxInSRC
      & \PendingTxInS \uniondistinct (\HashScr \times \Value) \uniondistinct \HashScr
      \\
      \var{ptxi}
      & \PendingTxIn
      & \PendingTxInV \uniondistinct \PendingTxInS
      \\
      \var{ptx}
      & \PendingTx
      & \powerset{\PendingTxIn} \times  \powerset{\TxOut} \times \Coin \times
      \PendingTxInSRC \times (\Slot\times\Slot)
      \\
    \end{array}
  \end{equation*}
  \caption{Definitions used to make PendingTx}
  \label{fig:defs:utxo-pending}
\end{figure*}


In Figure \ref{fig:defs:utxo-shelley-2}, the following types have changed:

\begin{itemize}
  \item $\TxBody$ was changed to have inputs of type $\TxInTx$, and the
  time to live $\Slot$ was replaced by a liveness interval $\Slot \times \Slot$,
  where the first slot is accessed by $\fun{txlst}$.
  \item $\TxBody$ now includes $\Value$, which represents
  the tokens forged and taken out of circulation by the transaction
  \item Not as part of the body, the transaction now also includes
  a finite map lookup $\Vlds$ to avoid having multiple
  copies of the validator (one for each input spending from that script).
  \item $\HashDat \mapsto \Data$ is a similar lookup for data scripts.
  The full data script is now optional to include in a transaction when
  paying to a script. It is never
  stored on-chain and is only provided for the spender of the output
  to be able to look it up when necessary (i.e. when spending the output),
  provided the block that contained it is still available to the spender.
  Supplying the full data script increases the size of the transaction and
  thus the fees.
  \item $\TxValTag$ is now part of the $\Tx$ type. This is a tag that is
  set by the slot leader submitting the block containing this transaction.
  It can later be used to re-apply blocks without performing script validation
  again.
  \item $\TxWitness$ is changed to exclude script witnesses. Only PK ones
  are included. Scripts are handled separately.
  \item $\fun{txinputs}$ type changed to map to $\TxInTx$
  \item $~\fun{txlst},~\fun{getValue},~\fun{getAddr},~\fun{txlst},~\fun{txvlds},~\fun{txdats},
  ~\fun{forged}$
  accessor functions added
\end{itemize}



\begin{figure*}[htb]
  \emph{Transaction Types}
  %
  \begin{align*}
    \var{txbody} ~\in~
    & \TxBody ~=~
    & \powerset{\TxInTx} \times (\Ix \mapsto \TxOut) \times \seqof{\DCert}
      \times \Coin \times \Value \times (\Slot\times\Slot) \\
    & ~& \times \Wdrl \times \Update
  \end{align*}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{wit} & \TxWitness & (\VKey \mapsto \Sig)
      \\
      \var{tx}
      & \Tx
      & \TxBody \times \TxWitness \times \Vlds \times (\HashDat \mapsto \Data) \times \TxValTag
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txinputs} & \Tx \to \powerset{\TxInTx} & \text{transaction inputs} \\
      \fun{txlst} & \Tx \to \Slot & \text{start of liveness interval} \\
      \fun{getValue} & \TxOut \to \Value & \text{output value} \\
      \fun{getAddr} & \TxOut \to \Addr & \text{output address} \\
      \fun{txvaltag} & \Tx \to \TxValTag & \text{transaction validation tag}\\
      \fun{txvlds} & \Tx \to \Vlds & \text{validator scripts}\\
      \fun{txdats} & \Tx \to (\HashDat \mapsto \Data) & \text{data scripts}\\
      \fun{forged} & \Tx \to \Value & \text{value forged by tx}\\
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system, cont.}
  \label{fig:defs:utxo-shelley-2}
\end{figure*}


In Figure \ref{fig:defs:functions-helper} are the helper functions used for
processing transaction data for validation.

\begin{itemize}
  \item $\fun{adaID},~\fun{adaToken},~\fun{qu},~\fun{coi},~\fun{adaVal}$ are used
  for converting between Ada and other currencies. $\Quantity$ and $\Coin$
  must both be of the same underlying type to be able to convert between them.
  \item $\fun{hashScript},~ \fun{hashData},~\fun{toData}$ are hashing and encoding
  abstract functions.
  \item $\fun{adaVal}$ is used to create a value term from a coin Ada amount
  \item The other functions are needed for building $\PendingTx$
  ($\fun{validationData}$ builds it).
\end{itemize}

\begin{figure*}[htb]
  \emph{Abstract Functions and Values}
  %
  \begin{align*}
    \mathsf{adaID} \in& ~\CurrencyId
    & \text{Ada currency ID} \\
    \mathsf{adaToken} \in& ~\Token
    & \text{Ada Token} \\
    \fun{qu} \in& ~\Coin \to \Quantity
    & \text{convert a coin amount into quantity} \\
    \fun{coi} \in& ~\Quantity \to \Coin
    & \text{convert a quantity into a coin value} \\
    \fun{hashScript} \in & ~\Script\to \HashScr
    & \text{compute script hash} \\
    \fun{hashData} \in & ~\Data \to \HashDat
    & \text{compute hash of data} \\
    \fun{toData} \in & ~\PendingTx\to \Data
    & \text{encode PendingTx as Data} \\
  \end{align*}
  \emph{Helper Functions}
  %
  \begin{align*}
    &\fun{adaVal} ~\in~ \Coin \to \Value \\
    &\fun{adaVal}~{c} ~=~ \mathsf{adaID} \mapsto (\mathsf{adaToken} \mapsto  \fun{qu}~c) \\
    & \text{make an Ada value term from a Coin} \\~\\
    & \fun{pendingTxIn} \in \TxInTx \to \Value \to \PendingTxIn \\
    & \fun{pendingTxIn}~\var{txin}~\var{c} = \\
    & ~~\begin{cases}
          (txin,~{hashscr_v},\fun{hashData}~{script_r},c)
           & \text{if}~\var{txin} = ((txid,ix),(\var{hashscr_v}, \var{script_r},\wcard)) \in \TxInScr \\
          ((txid,ix),c) & \text{if}~
           \var{txin} = ((txid,ix),\wcard) \in (\TxIn \times \IsFee)
      \end{cases}\\
    & \text{build pending Tx input} \\~\\
    & \fun{mkIns} \in \Tx \to \UTxO \to \powerset{\PendingTxIn} \\
    & \fun{mkIns}~\var{tx}~\var{utxo} = \\
    & ~~\{ \fun{pendingTxIn}~\var{txin}~(\fun{getValue}~\var{txout}) ~\vert~ \var{txin} \mapsto \var{txout}
    \in \fun{txins}~\var{tx} \restrictdom \var{utxo}\} \\
    & \text{build pending Tx inputs} \\~\\
    & \fun{validationData} \in \UTxO \to \Tx \to \PendingTxInSRC \to \PendingTx \\
    & \fun{validationData}~\var{utxo}~\var{tx}~\var{ptxrs} = \\ &
    ~~ ((\fun{mkIns}~\var{tx}~\var{utxo}),\{ \var{txout}~\vert~ \var{ix} \mapsto \var{txout} \in \fun{txouts}~\var{tx}\},
    \fun{txfee}~{tx},\var{ptxrs},(\fun{txlst}~{tx},\fun{txttl}~{tx})) \\
    & \text{build PendingTx} \\
  \end{align*}
  \caption{Script Validation}
  \label{fig:defs:functions-helper}
\end{figure*}


In Figure \ref{fig:defs:functions-valid}, functions for script validation
are presented.

\begin{itemize}
  \item $\fun{valMSIGupTo}$ performs validation for multi-sig scripts
  (this does not require data or redeemer scripts). The abstract $\ExUnits$
  type would be defined to have a MSIG constructor specifically to
  measure msig-related resources.
  \item $\fun{valPLCupTo}$ performs validation for plutus scripts.
  \begin{note}
    these need to be defined still
  \end{note}
\end{itemize}

These functions take their corresponding parameters (no data or redeemer
scripts in the case of multisig). They also
takes a term of type $\ExUnits$ as a parameter and perform validation
\textit{limited by resources indicated by} $exunits$.

\begin{note}
  $\fun{valScriptUpTo}$  is the name of the function that replaces
  $\fun{evaluateScript}$ in the existing multi-sig script validation
  scheme in the ledger spec.
\end{note}

\begin{figure*}[htb]
  \emph{Script Validation Functions}
  %
  \begin{align*}
    & \fun{valMSIGupTo} \in \ScriptMSig\to \Data \to \ExUnits \to\Bool \\
    & \text{resource-restricted validation of a multi-sig script} \\~\\
    & \fun{valPLCupTo} \in \ScriptPlutus\to (\Data \times \Data \times \Data \times
    \ExUnits) \to \Bool \\
    & \text{resource-restricted validation of a Plutus script}
  \end{align*}
  %
  \emph{Notation}
  %
  \begin{align*}
    \llbracket \var{script_v} \rrbracket_{\var{exunits}} (\var{script_d},~\var{script_r},~\var{ptx})
    &=& \fun{valPLCupTo} ~\var{script_v}~(\var{script_d},~\var{script_r},~\var{ptx},~
    \var{exunits})
    \nextdef
    \llbracket \var{script_v} \rrbracket_{\var{exunits}} ~\var{ptx}
    &=& \fun{valPLCupTo} ~\var{script_v} ~ \var{\Nothing}~\var{\Nothing}~\var{ptx}~
    \var{exunits} \\
    &=& \fun{valMSIGupTo} ~\var{script_v} ~\var{ptx}~
    \var{exunits}
  \end{align*}
  \caption{Script Validation, cont.}
  \label{fig:defs:functions-valid}
\end{figure*}


\clearpage
