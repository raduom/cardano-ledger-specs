\section{UTxO}
\label{sec:utxo}


\subsection{UTxO Transitions}
\label{sec:utxo-trans}

We have added several functions having to to with transaction and UTxO inputs and
outputs, which are used in defining the UTxO transition system. These are
given in Figure \ref{fig:functions:insouts}. These include

\begin{itemize}
  \item The function $\fun{txinputs_{vf}}$ returns only the inputs selected to be used
for paying transaction fees
  \item The function $\fun{txins}$ that returns $\TxIn$ part of both script
  and non-script transaction inputs.
  \item The function $\fun{outs}$ is unchanged
\end{itemize}

\begin{figure}[htb]
  \begin{align*}
    & \fun{txinputs_{vf}} \in \Tx \to \powerset{\TxIn}
    & \text{tx VK inputs used for fees} \\
    & \fun{txinputs_{vf}} ~tx~= \\
    &~~\{ (txid,ix)~\vert~((txid,ix),\var{isfee}) \in
    \fun{txinputs} ~tx\cap \TxIn,~
     \var{isfee}\in\Yes\}
    \nextdef
    & \fun{outs} \in \Tx \to \UTxO
    & \text{tx outputs as UTxO} \\
    & \fun{outs} ~ \var{tx} =
        \left\{
          (\fun{txid} ~ \var{tx}, \var{ix}) \mapsto \var{txout} ~
          \middle|
          \var{ix} \mapsto \var{txout} \in \txouts{tx}
        \right\} \\
    \nextdef
    & \fun{txins} \in \Tx \to \powerset{\TxIn} & \text{transaction inputs} \\
    & \fun{txins} ~\var{tx} = \{(txid,ix) \mid ((txid,ix),\wcard)\in\fun{txinputs} ~tx\} \\
  \end{align*}
  \caption{Functions on Tx Inputs and Outputs}
  \label{fig:functions:insouts}
\end{figure}


Figure~\ref{fig:functions:utxo} defines functions needed for the UTxO transition system.
The changes due to Plutus integration are as follows:

\begin{itemize}
  \item $\fun{txscrfee}$ returns the fee a transaction must pay for script
  execution based on current resource use pricing

  \item $\fun{adaAll}$ adds up all the Ada in a UTxO

  \item
    The $\fun{ubalance}$ function calculates the (aggregated by currency ID and
    Token) sum total of all the value in a given UTxO.

  \item The $\fun{consumed}$ calculation for the preservation of value remains the
  same. It is still the sum of the reward address coin consumed, the coin value
   UTxO entries consumed, the value forged by a transaction,
   and the value consumed from the deposit pot due
   to the transaction collecting deposit refunds.

  \item The $\fun{produced}$ calculation contains the fee a transaction pays
  to the fee pot (this consists of the sum of two values, a transaction fee and a
  fee for processing all the scripts inside it), the outputs it adds to the UTxO,
  and the deposits it makes
  to the deposit pot (these are the same values as the ledger spec).
  The script execution costs are included in the transaction fee.
\end{itemize}

The $\fun{consumed}$ and $\fun{produced}$ values are compared as $\Coin$.

\begin{figure}[htb]
  %
  \emph{Abstract Functions}
  \begin{align*}
    & \fun{txscrfee} \in \Prices \to \ExUnits \to \Coin \\
    & \text{calculates the script fee a transaction must pay} \\
  \end{align*}
  %
  \emph{Helper Functions}
  \begin{align*}
    & \fun{adaAll} \in \UTxO \to \Coin \\
    & \fun{adaAll}~{\var{utxo}} = \fun{coi}~
          (\sum  \range ({\mathsf{adaToken}} \restrictdom \range ({\mathsf{adaID}} \restrictdom
          \fun{ubalance}~\var{utxo}))) \\
    & \text{sum total of the amount of Ada in all outputs} \\
  \end{align*}
  %
  \emph{Main Calculations}
  \begin{align*}
    & \fun{ubalance} \in \UTxO \to \Value \\
    & \fun{ubalance} ~ utxo = \sum_{\wcard\mapsto\var{q}\in~\var{utxo}}
    \fun{getValue}~\var{q} \\
    & \text{UTxO balance} \\
    \nextdef
    & \fun{consumed} \in \PParams \to \UTxO \to \StakeDelegs \to \Wdrl \to \Tx \to \Value \\
    & \consumed{pp}{utxo}{stdelegs}{rewards}~{tx} = \\
    & ~~\ubalance{(\txins{tx} \restrictdom \var{utxo})} +
        \fun{adaVal}~(\fun{wbalance}~(\fun{txwdrls}~{tx}))~+~\fun{forged}~\var{tx} \\
    & ~~ + \fun{adaVal}~(\keyRefunds{pp}{stdelegs}{tx}) \\
    & \text{value consumed} \\
    \nextdef
    & \fun{produced} \in \PParams \to \StakePools \to \Tx \to \Value \\
    & \fun{produced}~\var{pp}~\var{stpools}~\var{tx} = \\
    &~~\ubalance{(\outs{tx})}  + \fun{adaVal}~(\txfee{tx} \\
    &~~ + \fun{txscrfee}~(\fun{prices}~{pp})~(\fun{txexunits}~{tx}) + \\
    &~~ \deposits{pp}{stpools}~{(\txcerts{tx})})\\
    & \text{value produced} \\
  \end{align*}
  \caption{Functions used in UTxO rules}
  \label{fig:functions:utxo}
\end{figure}

\clearpage

In the following Figure \ref{fig:functions:script1} we give the functions
related to sequential script validation.

\begin{figure}[htb]
  \begin{align*}
    & \fun{mkScrLst} \to \Tx \to \UTxO \to \seqof{(\ScriptV,\ScrInData)} \\
    & \text{a list of all validators and corresponding input data} \\
    & \fun{mkScrLst} ~\var{tx}~ \var{utxo} ~=~
    \fun{toList}~(\fun{allCertScrts}~{utxo}~{tx} \cup \fun{allWDRLSScrts}~{utxo}~{tx} \\
    & ~~ \cup \fun{allInsScrts}~{utxo}~{tx}) \\
  \end{align*}
  \caption{Script Cost Calculations}
  \label{fig:functions:script1}
\end{figure}

In Figure \ref{fig:functions:script2}, we give the three functions
used for script validation for a given transaction,

\begin{itemize}
\item $\fun{allCertScrts}$ returns the set of all the validators for the
key deregistration certificates, together
wtih the data needed for validation
\item $\fun{allWDRLSScrts}$ returns the set of all the validators locking
the script-address reward addresses together
wtih the data needed for validation
\item $\fun{allInsScrts}$ returns the set of all the validators locking
the script-address UTxO's together
wtih the data needed for validation
\end{itemize}

There are several pieces of data from different sources involved in building these
sets:

\begin{itemize}
\item the hash of the validator script, which is either the reward address,
the certificate witness, or the payment credential part of a UTxO address

* the corresponding
full validator is looked up (by hash value) in the finite map $\fun{txvlds}$ in the
body of the transaction, and must hash to the value by which it is indexed

\item the data values and redeemers, which are also looked up by hash in $\fun{txdats}~{tx}$

\item the validation data, built using the UTxO, the transaction itself,
and the current item being validated
\end{itemize}

Recall that $\fun{validationData}$ constructs the validation data (kept abstract
in this spec).
Note here that in all three cases, we may have a Plutus or a multisig script.
We use the same notation for both. Note also that in the case of UTxO
spending, we must distinguish the two cases: multisig (which cannot
have a data or redeemer arguments), and Plutus (which must explicitly be
applied to the provided data and redeemer scripts in this case).
This notational distinction is not necessary for certificates or reward withdrawals
because neither allow for non-empty data and redeemer scripts.

Note here that the wallet is responsible to determining the total price of the
validation of all the scripts in a transaction
by running the script itself to see how much resources it takes and doing the
fee calculation using the cost parameters in protocol parameters. It is then
also responsible for adding enough inputs to the transaction to cover the
fees required.

\begin{figure}[htb]
  \begin{align*}
    & \fun{allCertScrts} \in \PParams \to \UTxO \to \Tx \to \powerset{(\ScriptV \times \ScrInData)} \\
    & \text{check that all certificate witnessing scripts in a tx validate} \\
    & \fun{allCertScrts}~{utxo}~{tx}~=~ \\
    & ~~\{ (\var{script_v},
    \fun{validationData}~\var{utxo}~\var{tx}~\var{cert}) ~\vert \\
    & ~~\var{cert} \in (\DCertDeRegKey\cap\fun{txcerts}~\var{tx}), \\
    &~~\wcard\mapsto \var{script_v}\in \fun{regCred}~\var{cert}\restrictdom\fun{txvlds}~{tx}
     \} \\
    %
    \nextdef
    & \fun{allWDRLSScrts} \in \PParams \to \UTxO \to \Tx \to \powerset{(\ScriptV\times\ScrInData)} \\
    & \text{check that all reward withdrawal locking scripts in a tx validate} \\
    & \fun{allWDRLSScrts}~{utxo}~{tx}~=~ \\
    & ~~\{ (\var{script_v},\fun{validationData}~\var{utxo}~\var{tx}~
      (a\mapsto c)) ~\vert \\
    & ~~a \mapsto c \in\fun{txwdrls}~\var{tx}, \\
    & ~~\wcard\mapsto \var{script_v}\in \fun{validatorHash}~\var{a}\restrictdom\fun{txvlds}~{tx}\}\\
    %
    \nextdef
    & \fun{allInsScrts} \in \PParams \to \UTxO \to \Tx \to \powerset{(\ScriptV\times\ScrInData)} \\
    & \text{check that all UTxO entry locking scripts in a tx validate} \\
    & \fun{allInsScrts}~{utxo}~{tx}~=~ \{ (\var{script_v}, (\var{dataval},\var{rdmr}, \\
    & ~~ \fun{validationData}~\var{utxo}~\var{tx}~
      (txid,ix,\var{hash_r}))) ~\vert \\
    & ~~(txid,ix,\var{hash_r}) \in \fun{txinputs}~\var{tx}, \\
    & ~~\wcard \mapsto \var{rdmr} \in \var{hash_r}\restrictdom \fun{txdats}~{tx}, \\
    & ~~\wcard \mapsto ((a,v),h_d) \in \var{(txid,ix)}\restrictdom\var{utxo}, \\
    & ~~\wcard \mapsto \var{dataval} \in \var{h_d}\restrictdom \fun{txdats}~{tx}, \\
    & ~~\wcard\mapsto \var{script_v}\in \fun{validatorHash}~{a}\restrictdom\fun{txvlds}~{tx} \}\\
    & ~~\cup~ \\
    & ~~\{ (\var{script_v},\fun{validationData}~\var{utxo}~\var{tx}~
      (txid,ix)) ~\vert \\
    & ~~(txid,ix) \in \fun{txinputs}~\var{tx}, \\
    & ~~ \wcard \mapsto (a,v) \in \var{(txid,ix)}\restrictdom\var{utxo}, \\
    & ~~\wcard\mapsto \var{script_v}\in
     \fun{validatorHash}~\var{a}\restrictdom\fun{txvlds}~{tx}\}
  \end{align*}
  \caption{Script Cost Calculations}
  \label{fig:functions:script2}
\end{figure}

Figure \ref{fig:ts-types:utxo-scripts} gives the transition system for the second phase of
the two-phase script validation. The second phase requires actually running
the scripts to see if they validate. This system is similar to
the UTXO transition system, but signal here is a list of pairs of a validator
script and the corresponding input data. In addition, we keep track of the
execution units remaining that can be used to during script execution, $\var{remExU}$.

\begin{figure}[htb]
  \emph{Validation environment}
  \begin{equation*}
    \ValEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pp} & \PParams & \text{protocol parameters}\\
        \var{stkCreds} & \StakeCredential & \text{stake credential}\\
        \var{stpools} & \StakePools & \text{stake pool}\\
        \var{genDelegs} & \KeyHashGen\mapsto\KeyHash & \text{genesis key delegations} \\
        \var{tx} & \Tx & \text{transaction being processed} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Validation state}
  \begin{equation*}
    \ValState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{utxo} & \UTxO & \text{UTxO}\\
        \var{deposits} & \Coin & \text{deposits pot}\\
        \var{fees} & \Coin & \text{fee pot}\\
        \var{ups} & \UpdateState & \text{update state}\\
        \var{remExU} & \ExUnits & \text{exunits remaining to spend on validation} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Script transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxos}{\_} \var{\_}
    \subseteq \powerset (\ValEnv \times \ValState \times \seqof{\ScriptV\times\ScrInData} \times \ValState)
  \end{equation*}
  %
  \caption{UTxO script validation types}
  \label{fig:ts-types:utxo-scripts}
\end{figure}

The rules for the second-phase script validation are given in
Figure~\ref{fig:rules:utxo-scrval}. There are three transition rules.
The first rule, $\mathsf{Scripts\mbox{-}Val}$, applies when

\begin{itemize}
\item there
are no scripts to validate in the signal list (i.e. this is the base case of
induction when all the scripts have validated)
\item the validation tag is applied correctly (it is $\Yes$)
\end{itemize}

When this rule applies, the states of the UTxO, fee
  and deposit pots, and updates are updated exactly as in the current
  ledger spec.

The $\mathsf{Scripts\mbox{-}Stop}$ rule applies when

\begin{itemize}
  \item The currenct script-input pair being validated does not validate
  (because there are not enough $\ExUnits$ left or other reasons)
  \item The validation tag is $\Nope$
\end{itemize}

Its application results in the following state changes:

\begin{itemize}
  \item All the
  UTxO entries corresponding to the transaction inputs selected for covering
  script fees are removed

  \item The sum total of the value of the marked UTxO entries
  is added to the fee pot
\end{itemize}

The $\mathsf{Scripts\mbox{-}Ind}$ rule applies when

\begin{itemize}
  \item the current script being validated has validated
  \item there is a non-negative fee which remains to pay for validating
  the rest of the scripts in the list
  \item the validation tag is $\Yes$
  \item transition rules apply for rest of the list
\end{itemize}

The only state change in this rule is of the variable $\var{remExU}$.
It is decreased by subtracting the cost of the execution of the
current script from its current value.
This is the variable we use to keep track of the remaining funds for
script execution. If the transaction is overpaying ($\fun{txscrfee}~{tx}$
is too big), the whole fee is still taken.

All the $\UTxOState$ changes happen when one of the non-recursive rules
applies.

It is always in the interest of the slot leader to have the new block validate,
with as many valid transactions as possible. This general heuristic,
in the case of the UTXOS rule, motivates the
slot leader to:

\begin{itemize}
  \item correctly apply of the $\IsValidating$ tag,
  \item include transactions that validate in every way
  \textit{except possibly 2nd step script validation failure}
  \item exclude any transactions that are invalid
in some way \textit{other than 2nd step script validation failure}
\end{itemize}

We want to
throw away all the blocks which have transactions with these tags
applied incorrectly.
Note that the reason for having the correct validation tag added by the slot leader
to a transaction is that re-applying blocks would not require repeat
execution of scripts in the transactions inside a block.

\textbf{Plutus Scripts as Staking Credentials.}
Note also that we do allow the staking credentials part of a script
address to be a Plutus script. There is no way currently (and does not seem
like a worthy pursuit) to keep track of the specific data script associated with
the validator in the staking address. Thus, only validators with no
data script data needed for validation can be effectively used for this purpose.
This is not checked anywhere except at validation time. In particular,
using a validator that takes a non-trivial data script input as a staking credential
will result in the funds being locked forever in the associated rewards account.

\begin{figure}[htb]
  \begin{equation}
    \inference[Scripts-Val]
    {
    \fun{txvaltag}~\var{tx} \in \Yes  &
    \var{remExU}~\geq~0
    \\
    ~
    \\
    {
      \left(
        \begin{array}{r}
          \var{slot} \\
          \var{pp} \\
          \var{dms} \\
        \end{array}
      \right)
    }
    \vdash \var{ups} \trans{\hyperref[fig:rules:update]{up}}{\fun{txup}~\var{tx}} \var{ups'}
    \\~\\
    \var{refunded} \leteq \keyRefunds{pp}{stdelegs}~{tx}
    \\
    \var{decayed} \leteq \decayedTx{pp}{stdelegs}~{tx}
    \\
    \var{depositChange} \leteq
      (\deposits{pp}~{stpools}~{\txcerts{tx}}) - (\var{refunded} + \var{decayed})
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stdelegs}\\
      \var{stpools}\\
      \var{dms}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remExU}\\
      \end{array}
      \right)
      \trans{utxos}{\epsilon}
      \left(
      \begin{array}{r}
        \varUpdate{\var{(\txins{tx} \subtractdom \var{utxo}) \cup \outs{tx}}}  \\
        \varUpdate{\var{deposits} + \var{depositChange}} \\
        \varUpdate{\var{fees} + \txfee{tx} + \var{decayed}} \\
        \varUpdate{\var{ups'}} \\
        \var{remExU}\\
      \end{array}
      \right) \\
    }
  \end{equation}
  \begin{equation}
    \inference[Scripts-Stop]
    {
    (\var{isVal},\var{remExU'})~:=~ \llbracket \fun{fst}~{s} \rrbracket_
    {\fun{costm}~\var{pp},\var{remExU}} (\fun{snd}~{s})
    \\
    ~
    \\
    \fun{txvaltag}~\var{tx} \in \Nope &
    (\var{remExU'}~<~0 ~ \lor ~ \var{isVal}\in \Nope)
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stdelegs}\\
      \var{stpools}\\
      \var{dms}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remExU}\\
      \end{array}
      \right)
      \trans{utxos}{s;\Gamma}
      \left(
      \begin{array}{r}
        \varUpdate{\var{\fun{txinputs_{vf}}~{tx} \subtractdom \var{utxo}}}  \\
        \var{deposits} \\
        \varUpdate{\var{fees} + \fun{ubalance}~(\fun{txinputs_{vf}}~{tx}\restrictdom \var{utxo})} \\
        \var{ups} \\
        \var{remExU}\\
      \end{array}
      \right)
    }
  \end{equation}
  \begin{equation}
    \inference[Scripts-Ind]
    {
    (\var{isVal},\var{remExU''})~:=~ \llbracket \fun{fst}~{s} \rrbracket
    _{\fun{costm}~\var{pp},\var{remExU'}} (\fun{snd}~{s})
    \\
    ~
    \\
    (\var{remExU''}~\geq~0 ~ \wedge ~ \var{isVal}\in \Yes)
    \\
    ~
    \\
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stdelegs}\\
      \var{stpools}\\
      \var{dms}\\
      \var{tx}\\
    \end{array}
    }
      \vdash
      \left(
      {
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remExU}\\
      \end{array}
      }
      \right)
      \trans{utxos}{\Gamma}
      \left(
      {
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remExU'}\\
      \end{array}
      }
      \right)
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stdelegs}\\
      \var{stpools}\\
      \var{dms}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remExU}\\
      \end{array}
      \right)
      \trans{utxos}{\Gamma;s}
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \varUpdate{remExU''}\\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Script validation inference rules}
  \label{fig:rules:utxo-scrval}
\end{figure}

In Figure \ref{fig:rules:utxo-shelley}, we present the $\type{UTxO-inductive}$
transition rule. It has the following preconditions (the relevant ones remain
from the original Shelley spec):

\begin{itemize}
  \item the transaction is being processed within its validity interval

  \item the hash of the protocol parameters in the transaction matches
  the hash of their current values on the ledger

  \item the transaction has at least one input

  \item all inputs in a transaction correspond to UTxO entries

  \item the general accounting property holds

  \item the script fees a transaction pays are less than the max allowed

  \item the $\fun{txfee}~\var{tx} \leq ...$ check
  that the value of the outputs corresponding to the fee-marked inputs
  indeed covers the total fee amount - the transaction fee plus the
  script execution fees (and these inputs contain only
  Ada tokens)

  \item the transaction fee is at least the minimum fee it is obligated to pay

  \item If an input in the transaction is spending a script UTxO entry,
  the $\fun{txvlds}$ map contains the corresponding full validator, and
  if this validator is a Plutus script, the input must be a script input
  (i.e. contain a redeemer)

  \item If a transaction input is a Plutus script-type input (has a redeemer), the
  $\fun{txdats}$ map has full redeemer as well as the full data-value
  the hash of which is contained in the corresponding UTxO entry

  \item A transaction output paying to a Plutus script must be of type
  $\TxOutScr$, i.e. contain the hash of the data-value

  \item for each reward withdrawal from a script address, the transaction
  has the full validator in the metadata

  \item for each script-credential certificate, the transaction
  has the full validator in the metadata

  \item the hash indexes of all validators are their correct hashes

  \item the hash indexes of all $\Data$ values are their correct hashes

  \item all outputs of the transaction contain positive quantities

  \item the transaction size does not exceed maximum

  \item the UTXOS state transition is valid, with the signal being
  the full list of all scripts that need validating in the transaction, paired with
  their corresponding input data
\end{itemize}


\begin{figure}[htb]
  \begin{equation}\label{eq:utxo-inductive-shelley}
    \inference[UTxO-inductive]
    { \fun{txlst}~tx \leq \var{slot}
      & \fun{txttl}~tx \geq \var{slot}
      \\
      ~
      \\
      \txins{tx} \neq \emptyset
      & \txins{tx} \subseteq \dom \var{utxo}
      \\
      \consumed{pp}{utxo}{stdelegs}{rewards}~{tx} = \produced{pp}{stpools}~{tx}
      \\
      ~
      \\
      \fun{txexunits}~{tx} \leq \fun{maxTxExUnits}~{pp}
      \\
      ~
      \\
      \fun{ubalance}~(\fun{txinputs_{vf}}~{tx} \restrictdom \var{utxo}) = \\
      \{\mathsf{adaID} \mapsto
      (\mathsf{adaToken} \mapsto \var{q})~ \vert~ q \geq \txfee{tx}
      + \fun{txscrfee}~(\fun{prices}~{pp})~(\fun{txexunits}~{tx}) \} \\
      \minfee{pp}{tx} \leq \txfee{tx}
      \\
      ~
      \\
      \forall~\var{txin}\in\fun{txinputs}~{tx},
      \forall \wcard \mapsto \var{txout} \in \fun{inref}~{txin}\restrictdom\var{utxo}, \\
      \fun{getAddr}~\var{txout} \in \AddrScr \Rightarrow
      (\fun{validatorHash}~(\fun{getAddr}~\var{txout})\in \fun{dom}~(\fun{txvlds}~{tx})) \\
      \wedge ~(\forall \wcard\mapsto \var{vld} \in
      \fun{validatorHash}~(\fun{getAddr}~\var{txout}) \restrictdom \fun{txvlds}~{tx},
      \var{vld}\in \ScriptPlutus \Rightarrow ~\var{txin}\in\TxInScr)
      \\
      ~
      \\
      \forall~\var{(\var{txin},\var{hash_r})}\in\fun{txinputs}~{tx},
      (\var{hash_r} \in \fun{dom}(\fun{txdats}~{tx})) \\
      \wedge~(\forall \wcard \mapsto \var{(a,c,h_d)} \in \var{txin}\restrictdom\var{utxo},
      \var{h_d} \in \fun{dom}(\fun{txdats}~{tx}))
      \\
      ~
      \\
      \forall~\var{txout}\in\fun{txouts}~{tx},
      \forall \wcard\mapsto\var{vld}\in \\ \fun{validatorHash}~(\fun{getAddr}~{txout})\restrictdom\fun{txvlds}~{tx}, \\
      \var{vld} \in \ScriptPlutus \Rightarrow \var{txout}\in\TxOutScr
      \\
      ~
      \\
      \forall~(a\mapsto c)\in\fun{txwdrls}~{tx},~{a}\in \AddrRWDScr \Rightarrow
      \fun{validatorHash}~{a} \in \fun{dom}(\fun{txvlds}~{tx})
      \\
      ~
      \\
      \forall~\var{cert}\in\fun{txcerts}~{tx},~\fun{regCred}~{cert}\in \HashScr \Rightarrow \\
      \fun{regCred}~{cert} \in \fun{dom}(\fun{txvlds}~{tx}) ~\wedge~ \var{cert} \in\DCertDeRegKey
      \\
      ~
      \\
      \forall~\var{hashscr_v}\mapsto\var{script_v}\in\fun{txvlds}~{tx},
      \var{hashscr_v} = \fun{hashScript}~\var{script_v}
      \\
      ~
      \\
      \forall~\var{hash_d}\mapsto\var{dat}\in\fun{txdats}~{tx},
      \var{hash_d} = \fun{hashData}~\var{dat}
      \\
      ~
      \\
      \forall (\_\mapsto (\_, (\wcard \mapsto (\wcard \mapsto q)))) \in \txouts{tx}, q \geq 0
      \\
      \fun{txsize}~{tx}\leq\fun{maxTxSize}~\var{pp}
      \\
      ~
      \\
      \var{sLst} := \fun{mkScrLst}~\var{tx}~\var{utxo}
      \\
      ~
      \\
      {
        \begin{array}{c}
          \var{slot}\\
          \var{pp}\\
          \var{stdelegs}\\
          \var{stpools}\\
          \var{dms}\\
          \var{tx}\\
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{r}
            \var{utxo} \\
            \var{deposits} \\
            \var{fees} \\
            \var{ups}\\
            \var{\fun{txexunits}~{tx}}\\
          \end{array}
        \right)
      }
      \trans{utxos}{\var{sLst}}
      {
        \left(
          \begin{array}{r}
            \var{utxo'} \\
            \var{deposits'} \\
            \var{fees'} \\
            \var{ups'}\\
            \var{remExU}\\
          \end{array}
        \right)
      }
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stdelegs}\\
        \var{stpools}\\
        \var{dms}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups}\\
      \end{array}
      \right)
      \trans{utxo}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{\var{utxo'}}  \\
        \varUpdate{\var{deposits'}} \\
        \varUpdate{\var{fees'}} \\
        \varUpdate{\var{ups'}}\\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:rules:utxo-shelley}
\end{figure}

\clearpage


\subsection{Witnesses}
\label{sec:witnesses-shelley}

The script validation is no longer part of witnessing. Since depending on
the outcome of the validation, the UTxO itself is updated differently, we
have moved script validation from the witnessing transition rule to
the UTXO rule. The changes we have made to the functions in Figure
\ref{fig:functions-witnesses}, as well as the transition rule in Figure
\ref{fig:rules:utxow-shelley}, are only removing any
functions, predicates, and let-bindings having to do with scripts.

Note here that witnessing (at least for spending PK outputs) should ideally
be done before the second phase of script validation (i.e. scipt execution).
This is because script validation takes resources, and we want to ensure
that we only run the scripts if we expect that other things in the transaction are
valid and we do not have to throw it away after running the scripts (which means
the execution costs will not be covered).

Note here that the signatures done by the owners of the keys paying the fees
take on another purpose in light of this two-phase validation.
They now ensure that the parties paying the fees have signed off on all
inputs to script validation, which include

\begin{itemize}
  \item the hashes of the data values and redeemers
  \item the fees the transaction is paying for script execution
  \item the current cost model for resource use (used to calculate
  the required $\ExUnits$) and other relevant protocol parameters (hashed)
\end{itemize}

This way, the parties whose money is at risk in case of script validation
failure are assured of a deterministic outcome to this validation, since
all inputs to script validation are signed and thus not tampered with.


\begin{figure}[htb]
  \begin{align*}
    & \fun{propWits} \in \Update \to (\KeyHashGen\mapsto\VKey) \to \powerset{\KeyHash}
    & \text{hashkeys for proposals} \\
    & \fun{propWits}~(\var{pup},~\var{aup})~\var{dms} = \\
    & ~~\left\{
      \hashKey{vkey}
      \mid
      \var{gkey}\mapsto\var{vkey}\in
      \left(\left(\dom{\var{pup}}\cup\dom{\var{aup}}\right)\restrictdom\var{dms}\right)
      \right\}
  \end{align*}

  \begin{align*}
    & \hspace{-0.8cm}\fun{certWitsNeeded} \Tx \to \powerset{\Credential}
    & \text{certificates with witnesses} \\
    &  \hspace{-0.8cm}\fun{certWitsNeeded}~\var{tx} = \\
    & \bigcup\{\cwitness{c} \mid c \in \txcerts{tx} \setminus (\DCertRegKey\cup\DCertMir)\}
  \end{align*}

    \begin{align*}
    & \hspace{-0.8cm}\fun{witsVKeyNeeded} \in \UTxO \to \Tx \to (\KeyHashGen\mapsto\VKey) \to
      \powerset{\KeyHash}
    & \text{required key hashes} \\
    &  \hspace{-0.8cm}\fun{witsVKeyNeeded}~\var{utxo}~\var{tx}~\var{dms} = \\
    & ~~\{ \fun{paymentHK}~\fun{getAddr}~{txout} \mid i \mapsto \var{txout} \in \var{utxo},~i\in\fun{txinsVKey}~{tx} \} \\
    \cup & ~~
           \{\fun{stakeCred_r}~a\mid a\mapsto \wcard \in \AddrRWDVKey
      \restrictdom \txwdrls{tx}\}\\
    \cup & ~~(\AddrVKey ~\cap~\fun{certWitsNeeded}~{tx}) \\
    \cup & ~~\fun{propWits}~(\fun{txup}~\var{tx})~\var{dms} \\
    \cup & ~~\bigcup_{\substack{c \in \txcerts{tx} \\ ~c \in\DCertRegPool}} \fun{poolOwners}~{c}
  \end{align*}
  \caption{Functions used in witness rule}
  \label{fig:functions-witnesses}
\end{figure}


\begin{figure}
  \begin{equation}
    \label{eq:utxo-witness-inductive-shelley}
    \inference[UTxO-wit]
    {
      (utxo, \wcard, \wcard) \leteq \var{utxoSt} \\~\\
      \forall \var{vk} \mapsto \sigma \in \txwitsVKey{tx},
      \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma} \\
      \fun{witsVKeyNeeded}~{utxo}~{tx}~{dms} \subseteq \{ \hashKey \var{vk} \mid
      \var{vk}\in\dom{(\txwitsVKey{tx})} \}
      \\~\\
      genSig \leteq
      \left\{
        \fun{hashKey}~vk \vert gkey\mapsto vk \in\var{dms}
      \right\}
      \cap
      \left\{
        \fun{hashKey}~\var{vk} \vert \var{vk}\in\dom{(\txwitsVKey{tx})}
      \right\}
      \\
      \left\{
        c\in\txcerts{tx}~\cap\DCertMir
      \right\} \neq\emptyset \implies \vert genSig\vert \geq 5 \wedge
      \fun{d}~\var{pp} > 0
      \\~\\
      {
        \begin{array}{l}
          \var{slot}\\
          \var{pp}\\
          \var{stdelegs}\\
          \var{stpools}\\
          \var{dms}\\
        \end{array}
      }
      \vdash \var{utxoSt} \trans{\hyperref[fig:rules:utxo-shelley]{utxo}}{tx}
      \var{utxoSt'}\\
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stdelegs}\\
        \var{stpools}\\
        \var{dms}\\
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{tx} \varUpdate{\var{utxoSt'}}
    }
  \end{equation}
  \caption{UTxO with witnesses inference rules}
  \label{fig:rules:utxow-shelley}
\end{figure}


\clearpage
