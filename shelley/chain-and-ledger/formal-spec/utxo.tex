\section{UTxO}
\label{sec:utxo}


\subsection{UTxO Transitions}
\label{sec:utxo-trans}

We have added several functions having to to with transaction and UTxO inputs and
outputs, which are used in defining the UTxO transition system. These are
given in Figure \ref{fig:functions:insouts}. These include

\begin{itemize}
  \item The function $\fun{txinputs_{vf}}$ returns only the inputs selected to be used
for paying transaction fees
  \item The function $\fun{txinputs_s}$ returns only script transaction inputs
  \item The function $\fun{txins}$ that returns $\TxIn$ part of both script
  and non-script transaction inputs.
  \item The function $\fun{outs}$ is unchanged
\end{itemize}

\begin{figure}[htb]
  \begin{align*}
    & \fun{txinputs_{vf}} \in \Tx \to \powerset{\TxIn}
    & \text{tx VK inputs used for fees} \\
    & \fun{txinputs_{vf}} ~tx~= \\
    &~~\{ (txid,ix)~\vert~((txid,ix),\var{isfee}) \in
    \fun{txinputs} ~tx\cap \TxIn,~
     \var{isfee}\in\Yes\}
    \nextdef
    & \fun{txinputs_s} \in \Tx \to \powerset{\TxInScr}
    & \text{tx script inputs} \\
    & \fun{txinputs_s} ~tx ~=~ \fun{txinputs} ~tx\cap \TxInScr
    \nextdef
    & \fun{outs} \in \Tx \to \UTxO
    & \text{tx outputs as UTxO} \\
    & \fun{outs} ~ \var{tx} =
        \left\{
          (\fun{txid} ~ \var{tx}, \var{ix}) \mapsto \var{txout} ~
          \middle|
          \var{ix} \mapsto \var{txout} \in \txouts{tx}
        \right\} \\
    \nextdef
    & \fun{txins} \in \Tx \to \powerset{\TxIn} & \text{transaction inputs} \\
    & \fun{txins} ~\var{tx} = \{(txid,ix) \mid ((txid,ix),\wcard)\in\fun{txinputs} ~tx\} \\
  \end{align*}
  \caption{Functions on Tx Inputs and Outputs}
  \label{fig:functions:insouts}
\end{figure}


Figure~\ref{fig:functions:utxo} defines functions needed for the UTxO transition system.
The changes due to Plutus integration are as follows:

\begin{itemize}
  \item $\fun{adaAll}$ adds up all the Ada in a UTxO

  \item $\fun{adaOnly}$ adds up all Ada in a UTxO and returns 0 if there were
  non-Ada tokens in it.

  \item
    The $\fun{ubalance}$ function calculates the (aggregated by currency ID and
    Token) sum total of all the value in a given UTxO.

  \item The $\fun{consumed}$ calculation for the preservation of value remains the
  same. It is still the sum of the reward address coin consumed, the coin value
   UTxO entries consumed, the value forged by a transaction,
   and the value consumed from the deposit pot due
   to the transaction collecting deposit refunds.

  \item The $\fun{produced}$ calculation contains the fee a transaction pays
  to the fee pot, the outputs it adds to the UTxO, and the deposits it makes
  to the deposit pot (these are the same values as the ledger spec).
  The script execution costs are included in the transaction fee.
\end{itemize}


\begin{figure}[htb]
  %
  \emph{Helper Functions}
  \begin{align*}
    & \fun{adaAll} \in \UTxO \to \Coin \\
    & \fun{adaAll}~{\var{utxo}} = \fun{coi}~
          (\sum  \range ({\mathsf{adaToken}} \restrictdom \range ({\mathsf{adaID}} \restrictdom
          \fun{ubalance}~\var{utxo}))) \\
    & \text{sum total of the amount of Ada in all outputs} \\
    \nextdef
    & \fun{adaOnly} \in \UTxO \to \Coin \\
    & \fun{adaOnly}~{\var{utxo}} = \\
    & ~~\begin{cases}
          \fun{coi}~{q} ~& \text{if}~\fun{ubalance}~\var{utxo} = \{\mathsf{adaID} \mapsto
          (\mathsf{adaToken} \mapsto \var{q})\} \\
          0 & \text{otherwise}
      \end{cases}\\
    & \text{sum total of the amount of Ada-only outputs} \\
  \end{align*}
  %
  \emph{Main Calculations}
  \begin{align*}
    & \fun{ubalance} \in \UTxO \to \Value \\
    & \fun{ubalance} ~ utxo = \sum_{\wcard\mapsto\var{q}\in~\var{utxo}}
    \fun{getValue}~\var{q} \\
    & \text{UTxO balance} \\
    \nextdef
    & \fun{wbalance} \in \Wdrl \to \Coin \\
    & \fun{wbalance} ~ ws = \sum_{(\wcard\mapsto c)\in\var{ws}} c \\
    & \text{withdrawal balance} \\
    \nextdef
    & \fun{consumed} \in \PParams \to \UTxO \to \StakeDelegs \to \Wdrl \to \Tx \to \Value \\
    & \consumed{pp}{utxo}{stdelegs}{rewards}~{tx} = \\
    & ~~\ubalance{(\txins{tx} \restrictdom \var{utxo})} +
        \fun{adaVal}~(\fun{wbalance}~(\fun{txwdrls}~{tx}))~+~\fun{forged}~\var{tx} \\
    & ~~ + \fun{adaVal}~(\keyRefunds{pp}{stdelegs}{tx}) \\
    & \text{value consumed} \\
    \nextdef
    & \fun{produced} \in \PParams \to \StakePools \to \Tx \to \Value \\
    & \fun{produced}~\var{pp}~\var{stpools}~\var{tx} = \\
    &~~\ubalance{(\outs{tx})}
    + \fun{adaVal}~(\txfee{tx}) + \fun{adaVal}~(\deposits{pp}{stpools}~{(\txcerts{tx})})\\
    & \text{value produced} \\
  \end{align*}
  \caption{Functions used in UTxO rules}
  \label{fig:functions:utxo}
\end{figure}

\clearpage

In the following Figure \ref{fig:functions:script1} we give the functions
related to sequential script validation.

\begin{itemize}
\item jhk
\end{itemize}

\begin{figure}[htb]
  \begin{align*}
    & \fun{mkScrLst} \in \PParams \to \Tx \to \UTxO \to \seqof{(\ScriptV,\ScrInData)} \\
    & \text{a list of all validators and corresponding input data} \\
    & \fun{mkScrLst} ~\var{pp}~\var{tx}~ \var{utxo} ~=~
    \fun{toList}~(\fun{allCertScrts}~\var{pp}~{utxo}~{tx} \cup \fun{allWDRLSScrts}~\var{pp}~{utxo}~{tx} \\
    & ~~ \cup \fun{allInsScrts}~\var{pp}~{utxo}~{tx}) \\
  \end{align*}
  \caption{Script Cost Calculations}
  \label{fig:functions:script1}
\end{figure}

In Figure \ref{fig:functions:script2}, we give the three functions
used for script validation for a given transaction,

\begin{itemize}
\item $\fun{allCertScrts}$ returns the set of all the validators for the
key deregistration certificates, together
wtih the data needed for validation
\item $\fun{allWDRLSScrts}$ returns the set of all the validators locking
the script-address reward addresses together
wtih the data needed for validation
\item $\fun{allInsScrts}$ returns the set of all the validators locking
the script-address UTxO's together
wtih the data needed for validation
\end{itemize}

There are several pieces of data from different sources involved in building these
sets:

\begin{itemize}
\item the hash of the validator script, which is either the reward address,
the certificate witness, or the payment credential part of a UTxO address

* the corresponding
full validator is looked up (by hash value) in the finite map $\fun{txvlds}$ in the
body of the transaction, and must hash to the value by which it is indexed

\item the data script, which is included in the script input

* this data script must hash to the value stored in the UTxO entry correposing to
this transaction input

\item the redeemer script, provided in full as part of a script-spending
transaction input

\item the $\Value$ of the UTxO entry being spent, or the coin value associated
with reward address
\end{itemize}

Recall that $\fun{validationData}$ constructs the $\ValidationData$.
Note here that in all three cases, we may have a Plutus or a multisig script.
We use the same notation for both. Note also that in the case of UTxO
spending, we must distinguish the two cases: multisig (which cannot
have a data or redeemer arguments), and Plutus (which must explicitly be
applied to the provided data and redeemer scripts in this case).
This notational distinction is not necessary for certificates or reward withdrawals
because neither allow for non-empty data and redeemer scripts.

Note here that the wallet is responsible to determining the total price of the
validation of all the scripts in a transaction
by running the script itself to see how much resources it takes and doing the
fee calculation using the cost parameters in protocol parameters. It is then
also responsible for adding enough inputs to the transaction to cover the
fees required.

\begin{figure}[htb]
  \begin{align*}
    & \fun{allCertScrts} \in \PParams \to \UTxO \to \Tx \to \powerset{\ScriptV \times \ScrInData} \\
    & \text{check that all certificate witnessing scripts in a tx validate} \\
    & \fun{allCertScrts}~{pp}~{utxo}~{tx}~=~ \\
    & ~~\{ (\var{script_v},\fun{costm}~{pp}, \fun{toData}(\fun{validationData}~\var{utxo}~\var{tx}~\var{cert})) ~\vert \\
    & ~~\var{cert} \in (\DCertDeRegKey\cap\fun{txcerts}~\var{tx}), \\
    &~~\wcard\mapsto \var{script_v}\in \fun{regCred}~\var{cert}\restrictdom\fun{txvlds}~{tx}
     \} \\
    %
    \nextdef
    & \fun{allWDRLSScrts} \in \PParams \to \UTxO \to \Tx \to \powerset{\ScriptV\times\ScrInData} \\
    & \text{check that all reward withdrawal locking scripts in a tx validate} \\
    & \fun{allWDRLSScrts}~{pp}~{utxo}~{tx}~=~ \\
    & ~~\{ (\var{script_v},\fun{costm}~{pp},\fun{toData}(\fun{validationData}~\var{utxo}~\var{tx}~
      (a\mapsto c))) ~\vert \\
    & ~~a \mapsto c \in\fun{txwdrls}~\var{tx}, \\
    & ~~\wcard\mapsto \var{script_v}\in \fun{validatorHash}~\var{a}\restrictdom\fun{txvlds}~{tx}\}\\
    %
    \nextdef
    & \fun{allInsScrts} \in \PParams \to \UTxO \to \Tx \to \powerset{\ScriptV\times\ScrInData} \\
    & \text{check that all UTxO entry locking scripts in a tx validate} \\
    & \fun{allInsScrts}~{pp}~{utxo}~{tx}~=~ \{ (\var{script_v},\fun{costm}~{pp}, (\var{script_d},\var{script_r}, \\
    & ~~ \fun{toData}(\fun{validationData}~\var{utxo}~\var{tx}~
      (txid,ix,(\var{script_d},\var{script_r}))))) ~\vert \\
    & ~~(txid,ix,(\var{script_d},\var{script_r}) \in
    \fun{txinputs_s}~\var{tx}, \\
    & ~~\wcard \mapsto ((a,v),h_d) \in \var{(txid,ix)}\restrictdom\var{utxo}, \\
    & ~~\wcard\mapsto \var{script_v}\in \fun{validatorHash}~{a}\restrictdom\fun{txvlds}~{tx} \}\\
    & ~~\cup~ \\
    & ~~\{ (\var{script_v},\fun{costm}~{pp},\fun{toData}(\fun{validationData}~\var{utxo}~\var{tx}~
      (txid,ix))) ~\vert \\
    & ~~(txid,ix) \in \fun{txinputs_s}~\var{tx}, \\
    & ~~ \wcard \mapsto (a,v) \in \var{(txid,ix)}\restrictdom\var{utxo}, \\
    & ~~\wcard\mapsto \var{script_v}\in
     \fun{validatorHash}~\var{a}\restrictdom\fun{txvlds}~{tx}\}
  \end{align*}
  \caption{Script Cost Calculations}
  \label{fig:functions:script2}
\end{figure}

Figure \ref{fig:ts-types:utxo-scripts} gives the transition system for the second phase of
the two-phase script validation. The second phase requires actually running
the scripts to see if they validate.

\begin{figure}[htb]
  \emph{Validation environment}
  \begin{equation*}
    \ValEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pp} & \PParams & \text{protocol parameters}\\
        \var{stkCreds} & \StakeCredential & \text{stake credential}\\
        \var{stpools} & \StakePools & \text{stake pool}\\
        \var{genDelegs} & \KeyHashGen\mapsto\KeyHash & \text{genesis key delegations} \\
        \var{tx} & \Tx & \text{transaction being processed} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Validation state}
  \begin{equation*}
    \ValState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{utxo} & \UTxO & \text{UTxO}\\
        \var{deposits} & \Coin & \text{deposits pot}\\
        \var{fees} & \Coin & \text{fee pot}\\
        \var{ups} & \UpdateState & \text{update state}\\
        \var{remFee} & \Coin & \text{fee remaining to spend on validation} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Script transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxos}{\_} \var{\_}
    \subseteq \powerset (\ValEnv \times \ValState \times \seqof{\CurItem} \times \ValState)
  \end{equation*}
  %
  \caption{UTxO script validation types}
  \label{fig:ts-types:utxo-scripts}
\end{figure}

The rules for the second-phase script validation are given in
Figure~\ref{fig:rules:utxo-scrval}. There are two transition rules.
The first rule, $\mathsf{Scripts\mbox{-}Val}$,
is for the application of a transaction containing only
validating scripts. It applies when:

\begin{itemize}
  \item The validity tag of the transaction is $\Yes$
  (correponding predicate failure is \emph{BagValidationTag})
  \item All scripts (Plutus and multisig) in that transaction validate
  (correponding predicate failure is \emph{ScriptsDontValidate})
  \item The update proposals in this transaction result in a valid state change
\end{itemize}

When this rule applies, the states of the UTxO, fee
  and deposit pots, and updates are updated exactly as in the current
  ledger spec.

The $\mathsf{Scripts\mbox{-}NotVal}$ rule applies when

\begin{itemize}
  \item validation fails
  for one of the scripts in the transaction (only one script validation may fail,
  since validation does not proceed after this). In this case,
  \item The validation tag is $\Nope$
\end{itemize}

Its application results in the following state changes:

\begin{itemize}
  \item All the
  UTxO entries corresponding to the transaction inputs selected for covering
  script fees are removed

  \item The sum total of the value of the marked UTxO entries
  is added to the fee pot
\end{itemize}

It is always in the interest of the slot leader to have the new block validate,
with as many valid transactions as possible. This general heuristic,
in the case of the UTXOS rule, motivates the
slot leader to:

\begin{itemize}
  \item correctly apply of the $\IsValidating$ tag,
  \item include transactions that validate in every way
  \textit{except possibly 2nd step script validation failure}
  \item exclude any transactions that are invalid
in some way \textit{other than 2nd step script validation failure}
\end{itemize}

We want to
throw away all the blocks which have transactions with these tags
applied incorrectly.
Note that the reason for having the correct validation tag added by the slot leader
to a transaction is that re-applying blocks would not require repeat
execution of scripts in the transactions inside a block.

\textbf{Plutus Scripts as Staking Credentials.}
Note also that we do allow the staking credentials part of a script
address to be a Plutus script. There is no way currently (and does not seem
like a worthy pursuit) to keep track of the specific data script associated with
the validator in the staking address. Thus, only validators with no
data script data needed for validation can be effectively used for this purpose.
This is not checked anywhere except at validation time. In particular,
using a validator that takes a non-trivial data script input as a staking credential
will result in the funds being locked forever in the associated rewards account.

\begin{figure}[htb]
  \begin{equation}
    \inference[Scripts-Val]
    {
    \fun{txvaltag}~\var{tx} \in \Yes  &
    \var{remFee}~\geq~0
    \\
    ~
    \\
    {
      \left(
        \begin{array}{r}
          \var{slot} \\
          \var{pp} \\
          \var{dms} \\
        \end{array}
      \right)
    }
    \vdash \var{ups} \trans{\hyperref[fig:rules:update]{up}}{\fun{txup}~\var{tx}} \var{ups'}
    \\~\\
    \var{refunded} \leteq \keyRefunds{pp}{stdelegs}~{tx}
    \\
    \var{decayed} \leteq \decayedTx{pp}{stdelegs}~{tx}
    \\
    \var{depositChange} \leteq
      (\deposits{pp}~{stpools}~{\txcerts{tx}}) - (\var{refunded} + \var{decayed})
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stdelegs}\\
      \var{stpools}\\
      \var{dms}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remFee}\\
      \end{array}
      \right)
      \trans{utxos}{\epsilon}
      \left(
      \begin{array}{r}
        \varUpdate{\var{(\txins{tx} \subtractdom \var{utxo}) \cup \outs{tx}}}  \\
        \varUpdate{\var{deposits} + \var{depositChange}} \\
        \varUpdate{\var{fees} + \txfee{tx} + \var{decayed}} \\
        \varUpdate{\var{ups'}} \\
        \var{remFee}\\
      \end{array}
      \right) \\
    }
  \end{equation}
  \begin{equation}
    \inference[Scripts-Stop]
    {
    (\var{isVal},\var{remFee'})~:=~ \llbracket \fun{fst}~{s} \rrbracket (\fun{snd}~{s})
    \\
    ~
    \\
    \fun{txvaltag}~\var{tx} \in \Nope &
    (\var{remFee'}~<~0 ~ \lor ~ \var{isVal}\in \Nope)
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stdelegs}\\
      \var{stpools}\\
      \var{dms}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remFee}\\
      \end{array}
      \right)
      \trans{utxos}{s;\Gamma}
      \left(
      \begin{array}{r}
        \varUpdate{\var{\fun{txinputs_{vf}}~{tx} \subtractdom \var{utxo}}}  \\
        \var{deposits} \\
        \varUpdate{\var{fees} + \fun{ubalance}~(\fun{txinputs_{vf}}~{tx}\restrictdom \var{utxo})} \\
        \var{ups} \\
        \var{remFee}\\
      \end{array}
      \right)
    }
  \end{equation}
  \begin{equation}
    \inference[Scripts-Ind]
    {
    (\var{isVal},\var{remFee'})~:=~ \llbracket \fun{fst}~{s} \rrbracket (\fun{snd}~{s})
    \\
    ~
    \\
    (\var{remFee'}~\geq~0 ~ \wedge ~ \var{isVal}\in \Yes)
    \\
    ~
    \\
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stdelegs}\\
      \var{stpools}\\
      \var{dms}\\
      \var{tx}\\
    \end{array}
    }
      \vdash
      \left(
      {
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remFee'}\\
      \end{array}
      }
      \right)
      \trans{utxos}{\Gamma}
      \left(
      {
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remFee''}\\
      \end{array}
      }
      \right)
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stdelegs}\\
      \var{stpools}\\
      \var{dms}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remFee}\\
      \end{array}
      \right)
      \trans{utxos}{s;\Gamma}
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \varUpdate{remFee'}\\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Script validation inference rules}
  \label{fig:rules:utxo-scrval}
\end{figure}

In Figure \ref{fig:rules:utxo-shelley}, we present the $\type{UTxO-inductive}$
transition rule. It compares to the original rule in the Shelley ledger spec
as follows. The preconditions remain the same, with the following additions:

\begin{itemize}
  \item the $\fun{txfee}~\var{tx} \leq ...$ check
  that the value of the outputs corresponding to the inputs selected
  for paying script fees indeed covers the total fee amount (and does not
  include non-Ada tokens),

  \item the check that the transaction contains all the required validator
  scripts, and that the data scripts carried by the transaction inputs hash to the
  data hashes stored in the corresponding UTxO entry

  \item the check that the hash-indexed validator scripts in the transaction
  indeed correspond to their hash indexes

  \item the check that the hash-indexed data scripts in the
  transaction indeed correspond to their hash indexes,

  \item the UTXOS state transition.
\end{itemize}

Note that the types and rules for the UP transition (which is one of the
pre-conditions in the are $\type{UTxO-inductive}$ rule) are not included
in this document as there is no change there due to Plutus integration.
All of the state changes of the UTXO transition rules are prescribed by
the UTXOS transition in the precondition.


\begin{figure}[htb]
  \begin{equation}\label{eq:utxo-inductive-shelley}
    \inference[UTxO-inductive]
    { \txttl tx \geq \var{slot}
      & \txins{tx} \neq \emptyset
      & \txins{tx} \subseteq \dom \var{utxo}
      \\
      \consumed{pp}{utxo}{stdelegs}{rewards}~{tx} = \produced{pp}{stpools}~{tx}
      \\
      ~
      \\
      \txfee{tx} \leq
      \fun{ubalance}~(\fun{adaOnly}~(\fun{txinputs_{vf}}~{tx} \restrictdom \var{utxo})) \\
      \minfee{pp}{tx} \leq \txfee{tx}
      \\
      ~
      \\
      \forall~\var{(\var{txin},(script_d,\wcard,\wcard))}\in\fun{txinputs_s}~{tx}, \\
      \forall \wcard \mapsto \var{txout} \in \var{txin}\restrictdom\var{utxo}, \\
      \fun{validatorHash}~(\fun{getAddr}~\var{txout}) \in \fun{dom}~\fun{txvlds}~{tx} \\
      \wedge ~\fun{hashData}~{script_d}~=~ \fun{getDataHash}~\var{txout}
      \\
      ~
      \\
      \forall~\var{hashscr_v}\mapsto(\var{script_v},\wcard)\in\fun{txvlds}~{tx},
      \var{hashscr_v} = \fun{hashScript}~\var{script_v}
      \\
      ~
      \\
      \forall~\var{hashscr_d}\mapsto\var{script_d}\in\fun{txdats}~{tx},
      \var{hashscr_d} = \fun{hashData}~\var{script_d}
      \\
      ~
      \\
      \forall (\_\mapsto (\_, (\wcard \mapsto (\wcard \mapsto q)))) \in \txouts{tx}, q \geq 0
      \\
      \fun{txsize}~{tx}\leq\fun{maxTxSize}~\var{pp}
      \\
      ~
      \\
      \var{sLst} := \fun{mkScrLst}~\var{pp}~\var{tx}~\var{utxo}
      \\
      ~
      \\
      {
        \begin{array}{c}
          \var{slot}\\
          \var{pp}\\
          \var{stdelegs}\\
          \var{stpools}\\
          \var{dms}\\
          \var{tx}\\
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{r}
            \var{utxo} \\
            \var{deposits} \\
            \var{fees} \\
            \var{ups}\\
            \var{\txfee{tx}~-~\minfee{pp}{tx}}\\
          \end{array}
        \right)
      }
      \trans{utxos}{\var{sLst}}
      {
        \left(
          \begin{array}{r}
            \var{utxo'} \\
            \var{deposits'} \\
            \var{fees'} \\
            \var{ups'}\\
            \var{remFee'}\\
          \end{array}
        \right)
      }
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stdelegs}\\
        \var{stpools}\\
        \var{dms}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups}\\
      \end{array}
      \right)
      \trans{utxo}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{\var{utxo'}}  \\
        \varUpdate{\var{deposits'}} \\
        \varUpdate{\var{fees'}} \\
        \varUpdate{\var{ups'}}\\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:rules:utxo-shelley}
\end{figure}

\clearpage


\subsection{Witnesses}
\label{sec:witnesses-shelley}

The script validation is no longer part of witnessing. Since depending on
the outcome of the validation, the UTxO itself is updated differently, we
have moved script validation from the witnessing transition rule to
the UTXO rule. The changes we have made to the functions in Figure
\ref{fig:functions-witnesses}, as well as the transition rule in Figure
\ref{fig:rules:utxow-shelley}, are only removing any
functions, predicates, and let-bindings having to do with scripts.

Note here that witnessing (at least for spending PK outputs) must necessarily
be done before the second phase of script validation (i.e. scipt execution).
This is because script validation takes resources, the use of which must
be covered by fees regardless of whether the validation succeeds.
Note that if a block is deemed invalid for a reason other than
script validation failure, as usual the block will be discarded and
these fees will not be paid. Witnessing
guarantees that all PK outputs spending is authorized, and it is fine to
consume the PK outputs as fee payment. In the UTXOW transition rule,
this is the case. Witnessing predicates are first, followed by the UTXO transition
predicate.

\begin{figure}[htb]
  \begin{align*}
    & \fun{propWits} \in \Update \to (\KeyHashGen\mapsto\VKey) \to \powerset{\KeyHash}
    & \text{hashkeys for proposals} \\
    & \fun{propWits}~(\var{pup},~\var{aup})~\var{dms} = \\
    & ~~\left\{
      \hashKey{vkey}
      \mid
      \var{gkey}\mapsto\var{vkey}\in
      \left(\left(\dom{\var{pup}}\cup\dom{\var{aup}}\right)\restrictdom\var{dms}\right)
      \right\}
  \end{align*}

  \begin{align*}
    & \hspace{-0.8cm}\fun{certWitsNeeded} \Tx \to \powerset{\Credential}
    & \text{certificates with witnesses} \\
    &  \hspace{-0.8cm}\fun{certWitsNeeded}~\var{tx} = \\
    & \bigcup\{\cwitness{c} \mid c \in \txcerts{tx} \setminus (\DCertRegKey\cup\DCertMir)\}
  \end{align*}

    \begin{align*}
    & \hspace{-0.8cm}\fun{witsVKeyNeeded} \in \UTxO \to \Tx \to (\KeyHashGen\mapsto\VKey) \to
      \powerset{\KeyHash}
    & \text{required key hashes} \\
    &  \hspace{-0.8cm}\fun{witsVKeyNeeded}~\var{utxo}~\var{tx}~\var{dms} = \\
    & ~~\{ \fun{paymentHK}~\fun{getAddr}~{txout} \mid i \mapsto \var{txout} \in \var{utxo},~i\in\fun{txinsVKey}~{tx} \} \\
    \cup & ~~
           \{\fun{stakeCred_r}~a\mid a\mapsto \wcard \in \AddrRWDVKey
      \restrictdom \txwdrls{tx}\}\\
    \cup & ~~(\AddrVKey ~\cap~\fun{certWitsNeeded}~{tx}) \\
    \cup & ~~\fun{propWits}~(\fun{txup}~\var{tx})~\var{dms} \\
    \cup & ~~\bigcup_{\substack{c \in \txcerts{tx} \\ ~c \in\DCertRegPool}} \fun{poolOwners}~{c}
  \end{align*}
  \caption{Functions used in witness rule}
  \label{fig:functions-witnesses}
\end{figure}


\begin{figure}
  \begin{equation}
    \label{eq:utxo-witness-inductive-shelley}
    \inference[UTxO-wit]
    {
      (utxo, \wcard, \wcard) \leteq \var{utxoSt} \\~\\
      \forall \var{vk} \mapsto \sigma \in \txwitsVKey{tx},
      \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma} \\
      \fun{witsVKeyNeeded}~{utxo}~{tx}~{dms} \subseteq \{ \hashKey \var{vk} \mid
      \var{vk}\in\dom{(\txwitsVKey{tx})} \}
      \\~\\
      genSig \leteq
      \left\{
        \fun{hashKey}~vk \vert gkey\mapsto vk \in\var{dms}
      \right\}
      \cap
      \left\{
        \fun{hashKey}~\var{vk} \vert \var{vk}\in\dom{(\txwitsVKey{tx})}
      \right\}
      \\
      \left\{
        c\in\txcerts{tx}~\cap\DCertMir
      \right\} \neq\emptyset \implies \vert genSig\vert \geq 5 \wedge
      \fun{d}~\var{pp} > 0
      \\~\\
      {
        \begin{array}{l}
          \var{slot}\\
          \var{pp}\\
          \var{stdelegs}\\
          \var{stpools}\\
          \var{dms}\\
        \end{array}
      }
      \vdash \var{utxoSt} \trans{\hyperref[fig:rules:utxo-shelley]{utxo}}{tx}
      \var{utxoSt'}\\
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stdelegs}\\
        \var{stpools}\\
        \var{dms}\\
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{tx} \varUpdate{\var{utxoSt'}}
    }
  \end{equation}
  \caption{UTxO with witnesses inference rules}
  \label{fig:rules:utxow-shelley}
\end{figure}


\clearpage
