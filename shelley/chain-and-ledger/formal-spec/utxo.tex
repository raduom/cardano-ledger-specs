\section{UTxO}
\label{sec:utxo}


\subsection{UTxO Transitions}
\label{sec:utxo-trans}

We have added several functions having to to with transaction and UTxO inputs and
outputs, which are used in defining the UTxO transition system. These are
given in Figure \ref{fig:functions:insouts}. These include

\begin{itemize}
  \item The function $\fun{txinputs_{vf}}$ returns only the inputs selected to be used
for paying transaction fees
  \item The function $\fun{txins}$ that returns $\OutRef$ part of both script
  and non-script transaction inputs.
  \item The function $\fun{outs}$ adds the slot number of the block in which transaction is
  included to the outputs now
\end{itemize}

\begin{figure}[htb]
  \begin{align*}
    & \fun{txinputs_{vf}} \in \TxBody \to \powerset{\OutRef} \\
    & \text{tx VK inputs used for fees} \\
    & \fun{txinputs_{vf}} ~txb~= \\
    &~~\{ (txid,ix)~\vert~((txid,ix),\var{isfee}) \in
    \fun{txinputs} ~txb,~
     \var{isfee}\in\Yes\}
    \nextdef
    & \fun{getOut} \in \TxOut \to \OutFoo \\
    & \text{tx outputs transformed to UTxO outputs} \\
    & \fun{getOut} ~{txout}~= \begin{cases}
         \var{txout}  & \text{if~} \var{txout} \in \TxOutND \\
              (\fun{getAddr}~\var{txout}, \fun{getValue}~\var{txout},
              \fun{getDataHash}~\var{txout}) & \text{otherwise}
            \end{cases}
    \nextdef
    & \fun{outs} \in \Slot \to \TxBody \to \UTxO \\
    & \text{tx outputs as UTxO} \\
    & \fun{outs} ~ \var{slot}~\var{txb} =
        \left\{
          (\fun{txid} ~ \var{txb}, \var{ix}) \mapsto (\fun{getOut}~\var{txout},\var{slot}) ~
          \middle|~
          \var{ix} \mapsto \var{txout} \in \txouts{txb}
        \right\} \\
    \nextdef
    & \fun{txins} \in \TxBody \to \powerset{\OutRef} \\
    & \text{transaction inputs} \\
    & \fun{txins} ~\var{txb} = \{(txid,ix) \mid ((txid,ix),\wcard)\in\fun{txinputs} ~txb\} \\
  \end{align*}
  \caption{Functions on Tx Inputs and Outputs}
  \label{fig:functions:insouts}
\end{figure}


Figure~\ref{fig:functions:utxo} defines functions needed for the UTxO transition system.
The changes due to Plutus integration are as follows:

\begin{itemize}
  \item $\fun{txscrfee}$ returns the fee a transaction must pay for script
  execution based on current resource use pricing. Note that this value,
  like the non-script portion of the transaction fee, is calculated in $\Coin$,
  as fees can only be paid in Ada.

  \item $\fun{adaAll}$ adds up all the Ada in a UTxO and returns it as a
  $\Coin$ value

  \item
    The $\fun{ubalance}$ function calculates the (aggregated by currency ID and
    Token) sum total of all the value in a given UTxO.

  \item The $\fun{consumed}$ calculation for the preservation of value remains the
  same. It is still the sum of the reward address value consumed, the value
   UTxO entries consumed, the value forged by a transaction,
   and the value consumed from the deposit pot due
   to the transaction collecting deposit refunds.

  \item The $\fun{produced}$ calculation contains the fee a transaction pays
  to the fee pot (this consists of the sum of two values, a transaction fee and a
  fee for processing all the scripts inside it), the outputs it adds to the UTxO,
  and the deposits it makes
  to the deposit pot (these are the same values as the ledger spec).
  The script execution costs are included in the transaction fee.
  This calculation now takes the current slot number as an argument.
\end{itemize}

The $\fun{consumed}$ and $\fun{produced}$ values are compared as $\Value$.

\begin{figure}[htb]
  %
  \emph{Abstract Functions}
  \begin{align*}
    & \fun{txscrfee} \in \Prices \to \ExUnits \to \Coin \\
    & \fun{txscrfee}~ (\var{pr_{init}, pr_{mem}, pr_{steps}})~ (\var{mem, steps})
    = \var{pr_{init}} + \var{pr_{mem}}*\var{mem} + \var{pr_{steps}}*\var{steps} \\
    & \text{calculates the script fee a transaction must pay} \\
  \end{align*}
  %
  \emph{Helper Functions}
  \begin{align*}
    & \fun{adaAll} \in \UTxO \to \Coin \\
    & \fun{adaAll}~{\var{utxo}} ~=~\sum_{\{ q \mid \mathsf{adaID}\mapsto
      (\mathsf{adaToken}\mapsto q) \in \fun{ubalance}~\var{utxo}\}} \fun{co}~q \\
    & \text{sum total of the amount of Ada in all outputs} \\
  \end{align*}
  %
  \emph{Main Calculations}
  \begin{align*}
    & \fun{ubalance} \in \UTxO \to \Value \\
    & \fun{ubalance} ~ utxo = \sum_{\wcard\mapsto\var{(q,s)}\in~\var{utxo}}
    \fun{getValue}~\var{q} \\
    & \text{UTxO balance} \\
    \nextdef
    & \fun{consumed} \in \PParams \to \UTxO \to \StakeCreds \to \Wdrl \to \TxBody \to \Value \\
    & \consumed{pp}{utxo}{stkCreds}{rewards}~{txb} = \\
    & ~~\ubalance{(\txins{txb} \restrictdom \var{utxo})} +
        \fun{toValue} (\fun{wbalance}~(\fun{txwdrls}~{txb})~\\
        &~~+~ \keyRefunds{pp}{stkCreds}{txb}) +
        ~\fun{forge}~\var{txb} \\
    & \text{value consumed} \\
    \nextdef
    & \fun{produced} \in \Slot \to \PParams \to \StakePools \to \TxBody \to \Value \\
    & \fun{produced}~\var{slot}~\var{pp}~\var{stpools}~\var{txb} = \\
    &~~\ubalance{(\outs{slot}~{txb})}  + \fun{toValue} (\txfee{txb}
    + \fun{txscrfee}~(\fun{prices}~{pp})~(\fun{txexunits}~{txb}) \\
    &~~ + \deposits{pp}{stpools}~{(\txcerts{txb})})\\
    & \text{value produced} \\
  \end{align*}
  \caption{Functions used in UTxO rules}
  \label{fig:functions:utxo}
\end{figure}

\clearpage

\textbf{Putting Together Plutus Scripts and Their Inputs.}
In the following Figure \ref{fig:functions:script1} we give the functions
related to sequential Plutus script validation.



The map $\fun{finddata}$ returns the
data corresponding to the current item being validated, which, recall, can
be

\begin{itemize}
  \item the $\CurrencyId$ of a currency being forged by the transaction
  \item the certificate (only for delegation deregestration $\DCertDeRegKey$,
  as this is the only certificate type that allows script witnesses)
  \item the reward withdrawal $a \to c \in \Wdrl$
  \item the output reference $\OutRef$ for spending the corresponding output
  (for both the redeemer and the data value)
\end{itemize}

If there is no redeemer for the given item, the function returns $\Nothing_d$.
The reason for this is that every Plutus script must have all three arguments
of type $\Data$, of which $\Nothing_d$ is a term.

\textbf{Optional Redeemers.} Note that of the four items, only an
output-locking script can have a data-value. In other cases, there is no
notion of ledger-recorded "state", and hence no data-value.
The may have redeemers, however.
Allowing scripts to have redeemers could allow users to reduce the script
execution costs by avoiding unnecessary computation.

\textbf{Matching Scripts and Inputs.}
The function $\fun{mkPLCLst}$ returns a list of pairs of a validator script and
its inputs. In particular, it returns a validator script together with
 a list of the three $\Data$ values needed for validation (redeemer,
 data-value, and PendingTx). The execution units parameter is supplied
 directly during the application of the validation rule UTXOS.

\begin{figure}[htb]
  %
  \emph{Abstract functions}
  \begin{align*}
    &\fun{indexof} \in \DCert \to \seqof{\DCert} \to  \to \Ix\\
    &\fun{indexof} \in \Wdrl \to \Wdrl \to \Ix\\
    &\fun{indexof} \in \TxIn \to \powerset{\TxIn} \to \Ix\\
    &\fun{indexof} \in \Value \to \Value \to \Ix\\
    & \text{get the index of an item in the an ordered representation} \\
  \end{align*}
  %
  \emph{Helper functions}
  \begin{align*}
    &\fun{indexedScripts} \in \Tx \to (\ScriptHash \mapsto \Script) \\
    & \text{make a finite map of hash-indexed scripts} \\
    &\fun{indexedScripts}~{tx} ~=~ \{ h \mapsto s ~\vert~ \fun{hashScript}~{s}~=~h,
     s\in~\fun{txscripts}~(\fun{txwits}~{tx})\}
    \nextdef
    &\fun{indexedDats} \in \Tx \to (\DataHash \mapsto \Data)\\
    & \text{make a finite map of hash-indexed data values} \\
    &\fun{indexedDats}~{tx} ~=~ \{ h \mapsto d ~\vert~ \fun{hashData}~{d}~=~h,
     d\in~\fun{txdats}~(\fun{txwits}~{tx})\}
    \nextdef
    &\fun{findRdmr} \in \Tx \to \CurItem \to \powerset{\Data}\\
    & \text{get empty set or redeemer corresponding to index} \\
    & \fun{findRdmr}~{tx}~\var{it} ~=~ \{~ r ~\vert~ \\
    &~~(\mathsf{certTag}, \fun{indexof}~\var{it}~(\fun{txcerts}~{txb})) \mapsto ~r \in \fun{txrdmrs}~{txw} \\
    &~~\vee~ (\mathsf{wdrlTag}, \fun{indexof}~\var{it}~(\fun{txwdrls}~{txb}))
      \mapsto ~r \in \fun{txrdmrs}~{txw} \\
    &~~\vee~(\mathsf{forgeTag}, \fun{indexof}~\var{it}~(\fun{forge}~{txb}))  \mapsto ~r
      \in \fun{txrdmrs}~{txw} \\
    &~~\vee~(\mathsf{inputTag}, \fun{indexof}~\var{it}~(\fun{txinputs}~{txb})) \mapsto ~r
      \in \fun{txrdmrs}~{txw} \} \\
      & ~~\where \\
      & ~~~~~~~ \var{txb}~=~\txbody{tx} \\
      & ~~~~~~~ \var{txw}~=~\fun{txwits}~{tx}
    \nextdef
    & \fun{mkPLCLst} \to \PParams \to \Tx \to \UTxO \to \seqof{(\ScriptPlutus,\seqof{\Data})} \\
    & \text{a list of all Plutus validators and corresponding input data} \\
    & \fun{mkPLCLst}  ~\var{pp}~\var{tx}~ \var{utxo} ~=~
    \fun{toList}~(\fun{allCertScrts}~{utxo}~{tx} \cup \fun{allWDRLSScrts}~{utxo}~{tx} \\
    & ~~ \cup \fun{allInsScrts}~{utxo}~{tx} ~~ \cup \fun{forgedScrts}~{utxo}~{tx}) \\
  \end{align*}
  \caption{Combining Script Validators and their Inputs}
  \label{fig:functions:script1}
\end{figure}

In Figures \ref{fig:functions:script2} and \ref{fig:functions:script3},
we give the four functions
used for script validation for a given transaction,

\begin{itemize}
\item $\fun{allCertScrts}$ returns the set of all the validators for the
key deregistration certificates, together
wtih the data needed for validation
\item $\fun{allWDRLSScrts}$ returns the set of all the validators locking
the script-address reward addresses together
wtih the data needed for validation
\item $\fun{forgedScrts}$ returns the set of all the validators for
forging new tokens
\item $\fun{allInsScrts}$ returns the set of all the validators locking
the script-address UTxO's together
wtih the data needed for validation
\end{itemize}

Note that there are no "checks" done inside these functions. If there are
missing validators or inputs, or incorrect hashes, wrong type of script,
this is caught during the application of the UTXO
rule (before these functions are ever applied).
There are several pieces of data from different sources involved in building these
sets:

\begin{itemize}
\item the hash of the validator script, which is either the reward address,
the certificate witness, or the payment credential part of a UTxO address

\item the corresponding
full validator, which is looked up (by hash value) in the finite map $\fun{txscripts}$ in the
body of the transaction, and must hash to the value by which it is indexed

\item the data values and redeemers, which are also looked up by hash in $\fun{txdats}~{tx}$.
The hashes of data-values are stored on-chain in the outputs of the UTxO, and
the hashes of the redeemers are in the $\Rdmrs$ part of the transaction.

\item the validation data, built using the UTxO, the transaction itself,
and the current item being validated
\end{itemize}

Recall that $\fun{validationData}$ constructs the PendingTx (kept abstract
in this spec).
Recall also that when submitting a transaction, the wallet is responsible for
determining the total price of the
validation of all the Plutus scripts in a transaction
by running the script itself to see how much resources it takes and doing the
fee calculation using the cost model in protocol parameters. It is then
also responsible for adding enough inputs to the transaction to cover the
fees required.

\begin{figure}[htb]
  \begin{align*}
    & \fun{allCertScrts} \in \UTxO \to \Tx \to \powerset{(\ScriptPlutus \times \seqof{\Data})} \\
    & \text{check that all certificate witnessing scripts in a tx validate} \\
    & \fun{allCertScrts}~{utxo}~{tx}~=~ \\
    & ~~\{ (\var{script_v}, r;
    \fun{validationData}~\var{utxo}~\var{tx}~\var{cert}; \epsilon) ~\vert \\
    & ~~r \in \fun{findRdmr}~{tx}~\var{cert}, \\
    & ~~\var{cert} \in (\DCertDeRegKey\cap\fun{txcerts}~\txbody{tx}), \\
    &~~\fun{regCred}~\var{cert}\mapsto \var{script_v}\in \fun{indexedScripts}~{tx}, \\
    & ~~\var{script_v} \in \ScriptPlutus
     \}
    %
    \nextdef
    & \fun{allWDRLSScrts} \in \UTxO \to \Tx \to \powerset{(\ScriptPlutus\times\seqof{\Data})} \\
    & \text{check that all reward withdrawal locking scripts in a tx validate} \\
    & \fun{allWDRLSScrts}~{utxo}~{tx}~=~ \\
    & ~~\{ (\var{script_v}, r; \fun{validationData}~\var{utxo}~\var{tx}~
      (a\mapsto c); \epsilon) ~\vert \\
    &~~ r\in \fun{findRdmr}~{tx}~\var{(a\mapsto c)}, \\
    & ~~a \mapsto c \in\fun{txwdrls}~(\txbody{tx}), \\
    & ~~\fun{validatorHash}~\var{a}\mapsto \var{script_v}\in \fun{indexedScripts}~{tx}, \\
    & ~~ \var{script_v} \in \ScriptPlutus \}
    \nextdef
    %
    & \fun{forgedScrts} \in \UTxO \to \Tx \to \powerset{(\ScriptPlutus\times\seqof{\Data})} \\
    & \text{check that all forging scripts in a tx validate} \\
    & \fun{forgedScrts}~{utxo}~{tx}~=~\\
    & ~~\{ (\var{script_v}, r;
    \fun{validationData}~\var{utxo}~\var{tx}~\var{cid}; \epsilon) ~\vert \\
    & ~~r \in \fun{findRdmr}~{tx}~(\var{cid}\mapsto ~ \var{tkns}), \\
    & ~~\var{cid}\mapsto ~ \var{tkns} \in \fun{forge}~(\txbody{tx}), \\
    &~~\var{cid}\mapsto \var{script_v}\in \fun{indexedScripts}~{tx}
     \}
    %
  \end{align*}
  \caption{Scripts and their Arguments}
  \label{fig:functions:script2}
\end{figure}

\begin{figure}[htb]
  \begin{align*}
    & \fun{allInsScrts} \in \UTxO \to \Tx \to \powerset{(\ScriptPlutus\times\seqof{\Data})} \\
    & \text{check that all UTxO entry locking scripts in a tx validate} \\
    & \fun{allInsScrts}~{utxo}~{tx}~=~ \{ (\var{script_v}; (\var{d};\var{r}; \\
    & ~~ \fun{validationData}~\var{utxo}~\var{tx}~
      (txid,ix,\var{hash_r}))) ~\vert \\
    & ~~(txid,ix) \in \fun{txinputs}~(\txbody{tx}), \\
    & ~~\var{r} \in \fun{findRdmr}~{tx}~\var{(txid,ix)}, \\
    & ~~\var{(txid,ix)} \mapsto ((a,v),h_d) \in \var{utxo}, \\
    & ~~\var{h_d}\mapsto \var{d} \in \fun{indexedDats}~{tx}, \\
    & ~~(\fun{validatorHash}~{a})\mapsto \var{script_v}\in \fun{indexedScripts}~{tx} \}
  \end{align*}
  \caption{Scripts and their Arguments}
  \label{fig:functions:script3}
\end{figure}

\textbf{Two Phase Script Validation.}
Two phase Plutus script validation is necessary to ensure users pay for the
computational resources script validation uses.
Native script execution costs are expected to be much smaller than Plutus
scripts, and can be assesed and limited by the ledger rules directly.
Hence these scripts do not require two-phase validation. They are already
in use in the Shelley spec with a signle validation phase.

The first phase two-phase validation approach
performs every aspect of transaction validation except running the scripts.
The second phase is running the scripts.

Recall that, unlike native
multisignature scripts, Plutus scripts are opaque to the ledger. Recall also
that a transaction states a $\ExUnits$ "budget" to cover running all Plutus
scripts it is carrying. There is no way to check that this budget is enough,
except running the scripts. To avoid over-spending, we run them sequentially,
stopping whenever one does not validate, and charging the transaction the
fees. From the point of view of the ledger, there is no difference
between a script runnig out of $\ExUnits$ during validation, or not validating.
If a transaction contains an invalid script, the only change to the ledger
as a result of applying this transaction is the fees. Other parts of
the transaction cannot be processed correctly in this case.

Two phase validation requires a new transition system
(see Figure \ref{fig:ts-types:utxo-scripts}) to sequentially run
scripts and keep track of the execution units being spent as part of its state
($\var{remExU}$). The signal here is a sequence of pairs of a validator
script and the corresponding input data.

\begin{figure}[htb]
  \emph{Validation environment}
  \begin{equation*}
    \ValEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pp} & \PParams & \text{protocol parameters}\\
        \var{stkCreds} & \StakeCredential & \text{stake credential}\\
        \var{stpools} & \StakePools & \text{stake pool}\\
        \var{genDelegs} & \KeyHashGen\mapsto\KeyHash & \text{genesis key delegations} \\
        \var{tx} & \Tx & \text{transaction being processed} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Validation state}
  \begin{equation*}
    \ValState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{utxo} & \UTxO & \text{UTxO}\\
        \var{deposits} & \Value & \text{deposits pot}\\
        \var{fees} & \Value & \text{fee pot}\\
        \var{ups} & \UpdateState & \text{update state}\\
        \var{remExU} & \ExUnits & \text{exunits remaining to spend on validation} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Script transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxos}{\_} \var{\_}
    \subseteq \powerset (\ValEnv \times \ValState \times \seqof{(\ScriptPlutus\times\seqof{\Data})} \times \ValState)
  \end{equation*}
  %
  \caption{UTxO script validation types}
  \label{fig:ts-types:utxo-scripts}
\end{figure}

The rules for the second-phase script validation are given in
Figure~\ref{fig:rules:utxo-scrval}. There are three transition rules.
The first rule, $\mathsf{Scripts\mbox{-}Val}$, applies when

\begin{itemize}
\item there
are no scripts to validate in the signal list (i.e. this is the base case of
induction when all the scripts have validated)
\item the validation tag is applied correctly (it is $\Yes$)
\end{itemize}

When this rule applies, the states of the UTxO, fee
  and deposit pots, and updates are updated exactly as in the current
  ledger spec.

The $\mathsf{Scripts\mbox{-}Stop}$ rule applies when

\begin{itemize}
  \item The currenct script-input pair being validated does not validate
  (because there are not enough $\ExUnits$ left or other reasons)
  \item The validation tag is $\Nope$
\end{itemize}

Its application results in the following state changes:

\begin{itemize}
  \item All the
  UTxO entries corresponding to the transaction inputs selected for covering
  script fees are removed

  \item The sum total of the value of the marked UTxO entries
  is added to the fee pot
\end{itemize}

The $\mathsf{Scripts\mbox{-}Ind}$ rule applies when

\begin{itemize}
  \item the current script being validated has validated
  \item there is a non-negative fee which remains to pay for validating
  the rest of the scripts in the list
  \item the validation tag is $\Yes$
  \item transition rules apply for rest of the list
\end{itemize}

The only state change in this rule is of the variable $\var{remExU}$.
It is decreased by subtracting the cost of the execution of the
current script from its current value.
This is the variable we use to keep track of the remaining funds for
script execution. If the transaction is overpaying ($\fun{txscrfee}~{tx}$
is too big), the whole fee is still taken.

All the $\UTxOState$ changes happen when one of the non-recursive rules
applies.

It is always in the interest of the slot leader to have the new block validate,
with as many valid transactions as possible. This general heuristic,
in the case of the UTXOS rule, motivates the
slot leader to:

\begin{itemize}
  \item correctly apply of the $\IsValidating$ tag,
  \item include transactions that validate in every way
  \textit{except possibly 2nd step script validation failure}
  \item exclude any transactions that are invalid
in some way \textit{other than 2nd step script validation failure}
\end{itemize}

We want to
throw away all the blocks which have transactions with these tags
applied incorrectly.
Note that the reason for having the correct validation tag added by the slot leader
to a transaction is that re-applying blocks would not require repeat
execution of scripts in the transactions inside a block.
We also rely on correct use of tags in other rules (at this time, only in
the rules in Figure \ref{fig:rules:ledger}).

\begin{figure}[htb]
  \begin{equation}
    \inference[Scripts-Val]
    {
    \var{txb}\leteq\txbody{tx} \\
    \fun{txvaltag}~\var{tx} \in \Yes  &
    \var{remExU}~\geq~0
    \\
    ~
    \\
    {
      \left(
        \begin{array}{r}
          \var{slot} \\
          \var{pp} \\
          \var{genDelegs} \\
        \end{array}
      \right)
    }
    \vdash \var{ups} \trans{\hyperref[fig:rules:update]{up}}{\fun{txup}~\var{tx}} \var{ups'}
    \\~\\
    \var{refunded} \leteq \keyRefunds{pp}{stkCreds}~{txb}
    \\
    \var{decayed} \leteq \decayedTx{pp}{stkCreds}~{txb}
    \\
    \var{depositChange} \leteq
      (\deposits{pp}~{stpools}~{\txcerts{txb}}) - (\var{refunded} + \var{decayed})
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stkCreds}\\
      \var{stpools}\\
      \var{genDelegs}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remExU}\\
      \end{array}
      \right)
      \trans{utxos}{\epsilon}
      \left(
      \begin{array}{r}
        \varUpdate{\var{(\txins{txb} \subtractdom \var{utxo}) \cup \outs{slot}~{txb}}}  \\
        \varUpdate{\var{deposits} + \var{depositChange}} \\
        \varUpdate{\var{fees} + \txfee{txb} + \var{decayed}} \\
        \varUpdate{\var{ups'}} \\
        \var{remExU}\\
      \end{array}
      \right) \\
    }
  \end{equation}
  \begin{equation}
    \inference[Scripts-Stop]
    {
    \var{txb}\leteq\txbody{tx} \\
    (\var{isVal},\var{remExU'})~:=~ \llbracket \fun{fst}~{s} \rrbracket_
    {\fun{costm}~\var{pp},\var{remExU}} (\fun{snd}~{s})
    \\
    ~
    \\
    \fun{txvaltag}~\var{tx} \in \Nope &
    (\var{remExU'}~<~0 ~ \lor ~ \var{isVal}\in \Nope)
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stkCreds}\\
      \var{stpools}\\
      \var{genDelegs}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remExU}\\
      \end{array}
      \right)
      \trans{utxos}{s;\Gamma}
      \left(
      \begin{array}{r}
        \varUpdate{\var{\fun{txinputs_{vf}}~{txb} \subtractdom \var{utxo}}}  \\
        \var{deposits} \\
        \varUpdate{\var{fees} + \fun{ubalance}~(\fun{txinputs_{vf}}~{txb}\restrictdom \var{utxo})} \\
        \var{ups} \\
        \var{remExU}\\
      \end{array}
      \right)
    }
  \end{equation}
  \begin{equation}
    \inference[Scripts-Ind]
    {
    (\var{isVal},\var{remExU''})~:=~ \llbracket \fun{fst}~{s} \rrbracket
    _{\fun{costm}~\var{pp},\var{remExU'}} (\fun{snd}~{s})
    \\
    ~
    \\
    (\var{remExU''}~\geq~0 ~ \wedge ~ \var{isVal}\in \Yes)
    \\
    ~
    \\
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stkCreds}\\
      \var{stpools}\\
      \var{genDelegs}\\
      \var{tx}\\
    \end{array}
    }
      \vdash
      \left(
      {
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remExU}\\
      \end{array}
      }
      \right)
      \trans{utxos}{\Gamma}
      \left(
      {
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remExU'}\\
      \end{array}
      }
      \right)
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stkCreds}\\
      \var{stpools}\\
      \var{genDelegs}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \var{remExU}\\
      \end{array}
      \right)
      \trans{utxos}{\Gamma;s}
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
        \varUpdate{remExU''}\\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Script validation inference rules}
  \label{fig:rules:utxo-scrval}
\end{figure}

In Figure \ref{fig:rules:utxo-shelley}, we present the $\type{UTxO-inductive}$
transition rule. This is the rule where all the phase 1 validation occurs
(besides publik key witnessing).
It has the following preconditions (the relevant ones remain
from the original Shelley spec):

\begin{itemize}
  \item the transaction is being processed within its validity interval

  \item the transaction has at least one input

  \item all inputs in a transaction correspond to UTxO entries

  \item all inputs marked for-fees correspond to VK outputs

  \item the general accounting property holds

  \item no Ada is being forged

  \item all inputs marked for paying fees contain only Ada tokens

  \item the transaction fee (including the calculated script fee
  based on the execution units budget) is at least the minimum fee it is obligated to pay

  \item all outputs of the transaction contain positive quantities

  \item all Ada outputs of a transaction use the Ada token (no non-fungible Ada)

  \item the transaction size does not exceed maximum

  \item the execution units budget a transaction gives does not exceed the max
  allowed units

  \item If an input in the transaction is spending a Plutus script locked output,
  the $\fun{txscripts}$ map contains the corresponding full validator, and the
  $\fun{txdats}$ map has a key which is the
  data-value hash for this output stored in the ledger UTxO entry

  \item A transaction output paying to a Plutus script must
  contain the hash of the data-value (be of the $\TxOutP$ type)

  \item for each reward withdrawal from a Plutus script address, the transaction
  has the full validator in the metadata

  \item for each Plutus script-validated certificate, the transaction
  has the full validator in the metadata

  \item for each currency ID in the forged value of a transaction, the transaction
  has the full validator in the metadata

  \item the hash indexes of all validators are their correct hashes

  \item the transaction has the full redeemer in its metadata for every current
  item that has one (the ones that have one are listed in $\fun{rdmrs}$)

  \item the hash indexes of all $\Data$ values in the metadata are their correct hashes

  \item there are no unnecessary/unused validators attached to the transaction

  \item each validator version in the transaction has an associated cost model

  \item
  the hash of the subset of protocol parameters in the transaction body is equal to
  the hash of the same subset of protocol parameters currently on the ledger

  \item the UTXOS state transition is valid, with the signal ($\var{sLst}$) being
  the full list of all scripts that need validating in the transaction, paired with
  their corresponding input data
\end{itemize}


\begin{figure}[htb]
  \begin{equation}\label{eq:utxo-inductive-shelley}
    \inference[UTxO-inductive]
    {
      \var{txb}\leteq\txbody{tx} &
      \var{txw}\leteq\fun{txwits}~{tx} \\
      \fun{txlst}~txb \leq \var{slot}
      & \fun{txttl}~txb \geq \var{slot}
      \\
      \txins{txb} \neq \emptyset
      & \txins{txb} \subseteq \dom \var{utxo}
      \\
      \fun{range}~(\fun{txinputs_{vf}}~{txb} \restrictdom \var{utxo})
      \subseteq \TxOutND \\
      \consumed{pp}{utxo}{stkCreds}{rewards}~{txb} = \produced{slot}~{pp}~{stpools}~{txb}
      \\~\\
      \mathsf{adaID}\restrictdom \fun{forge}~{txb} = \epsilon
      \\
      ~
      \\
      \fun{dom}(\fun{ubalance}~(\fun{txinputs_{vf}}~{txb} \restrictdom \var{utxo})) = \mathsf{adaID} \\
      \fun{ubalance}~(\fun{txinputs_{vf}}~{txb} \restrictdom \var{utxo}) \geq
      \fun{toValue} ( \txfee{txb}
      + \fun{txscrfee}~(\fun{prices}~{pp})~(\fun{txexunits}~{txb}) ) \\
      \minfee{pp}{tx} \leq \txfee{txb}
      \\
      ~
      \\
      \forall txout \in \txouts{txb}, q~ \in~ \{~q~\vert~ c\mapsto (t\mapsto q) \in \fun{getValue}~txout\} \\
      \Rightarrow q ~\geq ~0 \\
      \forall \mathsf{adaID}\mapsto{tkns} \in \txouts{txb},
      \fun{dom}~\var{tkns} = \{\mathsf{adaToken}\}
      \\
      \fun{txsize}~{tx}\leq\fun{maxTxSize}~\var{pp}
      \\
      ~
      \\
      \fun{txexunits}~{txb} \leq \fun{maxTxExUnits}~{pp}
      \\
      ~
      \\
      \var{sLst} := \fun{mkPLCLst}~\var{tx}~\var{utxo}
      \\
      ~
      \\
      {
        \begin{array}{c}
          \var{slot}\\
          \var{pp}\\
          \var{stkCreds}\\
          \var{stpools}\\
          \var{genDelegs}\\
          \var{tx}\\
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{r}
            \var{utxo} \\
            \var{deposits} \\
            \var{fees} \\
            \var{ups}\\
            \var{\fun{txexunits}~{tx}}\\
          \end{array}
        \right)
      }
      \trans{utxos}{\var{sLst}}
      {
        \left(
          \begin{array}{r}
            \var{utxo'} \\
            \var{deposits'} \\
            \var{fees'} \\
            \var{ups'}\\
            \var{remExU}\\
          \end{array}
        \right)
      }
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stkCreds}\\
        \var{stpools}\\
        \var{genDelegs}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups}\\
      \end{array}
      \right)
      \trans{utxo}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{\var{utxo'}}  \\
        \varUpdate{\var{deposits'}} \\
        \varUpdate{\var{fees'}} \\
        \varUpdate{\var{ups'}}\\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:rules:utxo-shelley}
\end{figure}

\clearpage

\textbf{Witnessing.}

Plutus script validation is not part of witnessing because of the introduction
of two-phase validation, as this type of validation may result in two
different ways of updating the UTxO (fee payment only, or a full update).
Native script validation
still is, and we need to pick only the native scripts to validate as
part of witnessing.

 see Figure
\ref{fig:functions-witnesses}.


\begin{figure}[htb]
  \begin{align*}
      & \hspace{-1cm}\fun{scriptsNeeded} \in \UTxO \to \Tx \to
        (\CurItem \mapsto \ScriptHash)\\
      & \hspace{-1cm}\text{items that need script validation and corresponding script hashes} \\
      &  \hspace{-1cm}\fun{scriptsNeeded}~\var{utxo}~\var{tx} = \\
      & ~~\{ i \mapsto \fun{validatorHash}~(\fun{getAddr}~{txout}) \mid i \mapsto \var{txout} \in \var{utxo},\\
      & ~~~~~i\in\fun{txinsScript}~{(\fun{txinputs}~\var{txb})}~{utxo}\} \\
      \cup & ~~\{ (a\mapsto c) \mapsto \fun{stakeCred_{r}}~\var{a} \mid a \mapsto c \in \fun{txwdrls}~\var{txb}),
         a\in \AddrRWDScr \} \\
        \cup & ~~\{ cert \mapsto a \mid a \in\AddrScr \cap \fun{certWitsNeeded}~{txb}\} \\
        \cup & ~~\{ (cid \mapsto \var{tkns}) \mapsto \var{cid} \mid cid \mapsto \var{tkns}~\in~\fun{forge}~{txb} \} \\
      & \where \\
      & ~~~~~~~ \var{txb}~=~\txbody{tx} \\
      & ~~~~~~~ \var{txw}~=~\fun{txwits}~{tx}
  \end{align*}
  \caption{Functions used in witness rule}
  \label{fig:functions-witnesses}
\end{figure}

Anything having to do with multisig scripts is checked in the UTXOW rule.

\begin{figure}
  \begin{equation}
    \label{eq:utxo-witness-inductive-shelley}
    \inference[UTxO-wit]
    {
      \var{txb}\leteq\txbody{tx} &
      \var{txw}\leteq\fun{txwits}~{tx} \\
      (utxo, \wcard, \wcard, \wcard) \leteq \var{utxoSt} \\
      \var{witsKeyHashes} \leteq \{\fun{hashKey}~\var{vk} \vert \var{vk} \in
      \dom (\txwitsVKey{txw}) \}\\~\\
      \forall \var{validator} \in \fun{txscripts}~{txw} \cap \ScriptMSig,\\
      \fun{runMSigScript}~\var{validator}~\var{tx}\\~\\
      \range~(\fun{scriptsNeeded}~\var{utxo}~\var{tx}) ~=~ \dom (\fun{indexedScripts}~{tx}) \\
      \forall c\mapsto h \in ~\fun{scriptsNeeded}~\var{utxo}~\var{tx}, ~h\mapsto s~\in~\fun{indexedScripts}~{tx},\\
       s \in \ScriptPlutus~\Rightarrow~\fun{findRdmr}~{tx}~{c}\neq \{\}
      \\~\\
      \forall \var{cert}~\in~\fun{txcerts}~{txb}, \fun{regCred}~{cert}\in \ScriptHash \Rightarrow \\
      \var{cert} \in~ \DCertDeRegKey
      \forall~\var{txin}\in\fun{txinputs}~{txb},
      \var{txin} \mapsto \var{(\wcard,\wcard,h_d)} \in \var{utxo},
      \var{h_d} \in \fun{dom}(\fun{indexedDats}~{txw})
      \\
      ~
      \\
      \forall~ix \mapsto (a,v,d_h,\var{hdv}) ~\in~\fun{txouts}~{txb}, \\
      \var{hdv}~ = ~\Yes~ \Rightarrow \var{d_h}\in \fun{dom}~ (\fun{indexedDats}~{txw})
      \\
      ~
      \\
      \fun{cmlangs}~(\fun{txscripts}~\var{txw}) \subseteq \fun{dom}~(\fun{costmdls}~{pp}) \\
      \fun{cmlangs}~(\fun{txscripts}~\var{txw}) ~=~ \{\} \Rightarrow \fun{ppHash}~{txb}~=~\Nothing \\ \fun{cmlangs}~(\fun{txscripts}~\var{txw}) \neq \{\} \Rightarrow \\
      \fun{hashLanguagePP}~\var{pp}~(\fun{cmlangs}~(\fun{txscripts}~\var{txw})) =  \fun{ppHash}~{txb} \\~\\
      \fun{txdats}~\var{txw} ~=~ \{\} \Rightarrow \fun{rdmrsHash}~{txb}~=~\Nothing \\
      \fun{txdats}~\var{txw} ~\neq~ \{\} \Rightarrow
      \fun{hash}~(\fun{txdats}~\var{txw})~ =~  \fun{rdmrsHash}~{txb} \\
      \\~\\
      \forall \var{vk} \mapsto \sigma \in \txwitsVKey{txw},
      \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma} \\
      \fun{witsVKeyNeeded}~{utxo}~{tx}~{genDelegs} \subseteq \var{witsKeyHashes}
      \\~\\
      genSig \leteq
      \left\{
        \fun{hashKey}~gkey \vert gkey \in\dom{genDelegs}
      \right\}
      \cap
      \var{witsKeyHashes}
      \\
      \left\{
        c\in\txcerts{txb}~\cap\DCertMir
      \right\} \neq\emptyset \implies \vert genSig\vert \geq \Quorum \wedge
      \fun{d}~\var{pp} > 0
      \\~\\
      \var{mdh}\leteq\fun{txMDhash}~\var{txb}
      &
      \var{md}\leteq\fun{txMD}~\var{tx}
      \\
      (\var{mdh}=\Nothing \land \var{md}=\Nothing)
      \lor
      (\var{mdh}=\fun{hashMD}~\var{md})
      \\~\\
      {
        \begin{array}{r}
          \var{slot}\\
          \var{pp}\\
          \var{stkCreds}\\
          \var{stpools}\\
          \var{genDelegs}\\
        \end{array}
      }
      \vdash \var{utxoSt} \trans{\hyperref[fig:rules:utxo-shelley]{utxo}}{tx}
      \var{utxoSt'}\\
    }
    {
      \begin{array}{r}
        \var{slot}\\
        \var{pp}\\
        \var{stkCreds}\\
        \var{stpools}\\
        \var{genDelegs}\\
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{tx} \varUpdate{\var{utxoSt'}}
    }
  \end{equation}
  \caption{UTxO with witnesses inference rules}
  \label{fig:rules:utxow-shelley}
\end{figure}

\clearpage
