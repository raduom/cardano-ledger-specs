\section{Blockchain layer}
\label{sec:chain}

\newcommand{\Proof}{\type{Proof}}
\newcommand{\Seedl}{\mathsf{Seed}_\ell}
\newcommand{\Seede}{\mathsf{Seed}_\eta}
\newcommand{\activeSlotCoeff}[1]{\fun{activeSlotCoeff}~ \var{#1}}
\newcommand{\slotToSeed}[1]{\fun{slotToSeed}~ \var{#1}}

\newcommand{\T}{\type{T}}
\newcommand{\vrf}[3]{\fun{vrf}_{#1} ~ #2 ~ #3}
\newcommand{\verifyVrf}[4]{\fun{verifyVrf}_{#1} ~ #2 ~ #3 ~#4}

\newcommand{\HashHeader}{\type{HashHeader}}
\newcommand{\HashBBody}{\type{HashBBody}}
\newcommand{\bhHash}[1]{\fun{bhHash}~ \var{#1}}
\newcommand{\bHeaderSize}[1]{\fun{bHeaderSize}~ \var{#1}}
\newcommand{\bSize}[1]{\fun{bSize}~ \var{#1}}
\newcommand{\bBodySize}[1]{\fun{bBodySize}~ \var{#1}}
\newcommand{\OCert}{\type{OCert}}
\newcommand{\BHeader}{\type{BHeader}}
\newcommand{\BHBody}{\type{BHBody}}

\newcommand{\bheader}[1]{\fun{bheader}~\var{#1}}
\newcommand{\hsig}[1]{\fun{hsig}~\var{#1}}
\newcommand{\bprev}[1]{\fun{bprev}~\var{#1}}
\newcommand{\bhash}[1]{\fun{bhash}~\var{#1}}
\newcommand{\bvkcold}[1]{\fun{bvkcold}~\var{#1}}
\newcommand{\bseedl}[1]{\fun{bseed}_{\ell}~\var{#1}}
\newcommand{\bprfn}[1]{\fun{bprf}_{n}~\var{#1}}
\newcommand{\bseedn}[1]{\fun{bseed}_{n}~\var{#1}}
\newcommand{\bprfl}[1]{\fun{bprf}_{\ell}~\var{#1}}
\newcommand{\bocert}[1]{\fun{bocert}~\var{#1}}
\newcommand{\bnonce}[1]{\fun{bnonce}~\var{#1}}
\newcommand{\bleader}[1]{\fun{bleader}~\var{#1}}
\newcommand{\hBbsize}[1]{\fun{hBbsize}~\var{#1}}
\newcommand{\bbodyhash}[1]{\fun{bbodyhash}~\var{#1}}
\newcommand{\overlaySchedule}[4]{\fun{overlaySchedule}~\var{#1}~\var{#2}~{#3}~\var{#4}}

\newcommand{\PrtclState}{\type{PrtclState}}
\newcommand{\PrtclEnv}{\type{PrtclEnv}}
\newcommand{\OverlayEnv}{\type{OverlayEnv}}
\newcommand{\VRFState}{\type{VRFState}}
\newcommand{\NewEpochEnv}{\type{NewEpochEnv}}
\newcommand{\NewEpochState}{\type{NewEpochState}}
\newcommand{\PoolDistr}{\type{PoolDistr}}
\newcommand{\BBodyEnv}{\type{BBodyEnv}}
\newcommand{\BBodyState}{\type{BBodyState}}
\newcommand{\RUpdEnv}{\type{RUpdEnv}}
\newcommand{\ChainEnv}{\type{ChainEnv}}
\newcommand{\ChainState}{\type{ChainState}}
\newcommand{\ChainSig}{\type{ChainSig}}



\subsection{Block Body Transition}
\label{sec:block-body-trans}


In Figure~\ref{fig:rules:bbody}, we have added two checks :

\begin{itemize}
  \item the check that the sum total of
script fees all transactions in a block pay do not exceed the maximum total fees per
block (stored as a protocol parameter).

  \item a check that, for every transaction in the block being validated,
the hash of the subset of protocol parameters in the transaction body is equal to
as the hash of the same subset of protocol parameters currently on the ledger
\end{itemize}

To select the right subset of ledger protocol parameters to hash, we need to
first make a set of all the interpreter versions of all the scripts the
transaction is carrying. This is done by the function $\fun{versions}$,
see Figure \ref{fig:defs:functions-chain-helper}. Then, the parameters
relevant to all those versions are selected and hashed by $\fun{hashPlutusPP}$.

Note that at this time, only data from the protocol parameters must be hashed
for the comparison we defined. For future Plutus versions, parts of the ledger
state may need to be included in this hash as well, if they are passed as
arguments to the new interpreter versions. Note also that data from the UTxO
is passed to the interpreter, but does not require this type of hash comparison.
This is because if the entries the transaction being processed is trying to
spend have already been spent, there is a phase 1 validation check that
will fail.

\textbf{Parameter Hash Comparison Considerations.}
In the future, additional functionality may be supported by the ledger that
allows a sequence of transactions built over a period of time to be put on-chain
as a single transaction. Over this period of time, the parameter or ledger
data that must be passed as an argument to script interpreters could have changed.
The resulting transaction to be put on the chain (that contains the whole sequence of
transactions) is still obligated to include the hash of the current parameters
and any additional script processing fees.

Additional fees may be required because of the changes in prices or the cost model
for script interpreter versions of the scripts inside the transaction.

\begin{figure*}[htb]
  \emph{Abstract Functions and Values}
  %
  \begin{align*}
    \fun{versions} \in& \Vlds \to \powerset{(\PlutusVer)} \\
    \fun{versions} \\
    \text{Ada currency ID} \\
  \end{align*}
  \caption{Script Validation}
  \label{fig:defs:functions-chain-helper}
\end{figure*}


\begin{figure}[ht]
  \begin{equation}\label{eq:bbody}
    \inference[Block-Body]
    {
      \var{txs} \leteq \bbody{block}
      &
      \var{bhb} \leteq \bhbody\bheader{block}
      &
      \var{hk} \leteq \hashKey\bvkcold{bhb}
      \\~\\
      \bBodySize{txs} = \hBbsize{bhb}
      &
      \fun{hash}~{txs} = \bbodyhash{bhb}
      \\~\\
      \sum_{tx\in txs} \fun{txexunits}~{tx} \leq \fun{maxBlockExUnits}~\var{pp}
      \\~\\
      \forall~tx\in txs,~\fun{hashPlutusPP}~\var{pp}~(\fun{versions}~(\fun{txvlds}~\var{tx})) =  \fun{hashPP}~{tx}
      \\~\\
      {
        {\begin{array}{c}
                 \bslot{bhb} \\
                 \var{pp} \\
                 \var{reserves}
        \end{array}}
        \vdash
             \var{ls} \\
        \trans{\hyperref[fig:rules:ledger-sequence]{ledgers}}{\var{txs}}
             \var{ls}' \\
      }
    }
    {
      {\begin{array}{c}
               \var{oslots} \\
               \var{pp} \\
               \var{reserves}
      \end{array}}
      \vdash
      {\left(\begin{array}{c}
            \var{ls} \\
            \var{b} \\
      \end{array}\right)}
      \trans{bbody}{\var{block}}
      {\left(\begin{array}{c}
            \varUpdate{\var{ls}'} \\
            \varUpdate{\fun{incrBlocks}~{(\bslot{bhb}\in\var{oslots})}~{hk}~{b}} \\
      \end{array}\right)}
    }
  \end{equation}
  \caption{BBody rules}
  \label{fig:rules:bbody}
\end{figure}
